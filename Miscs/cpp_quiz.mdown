# Cpp Quiz

## Array is sure not pointer!
```c++
int arr[1]; 
int *p;
arr = xxx; // Error 
p = xxx; // OK 

int arr[10]; 
int *p = (int*)malloc(sizeof(int)*10)Ôºõ 
size_t as = sizeof(arr); // 40 
size_t ps = sizeof(p); // 4
```

## Bad, bad VLA
```c++
// Only valid in C99 and optional C11 (GNU11)
int a = 100;
int v[a] = {0};
sizeof(v); // 400! runtime evaluation
```

## aggr-init vs. delete function
* [dis](https://stackoverflow.com/q/33988297/8563711)
* [change-in-C++17](https://stackoverflow.com/questions/47656093/changed-rules-for-protected-constructors-in-c17)
```c++
struct Foo {
    Foo(const Foo &) = delete;
};

int main() { Foo bar{}, b2{ Foo{} }; } // OK

class Foo {
    Foo(const Foo &) = delete;
};
int main() { Foo bar{}, b2{ Foo{} }; } // OK

struct Foo {
    explicit Foo(const Foo &) = delete;
};
int main() { Foo bar{}, b2{ Foo{} }; } // Error

struct Foo {
    Foo() = delete;
};
int main() { Foo bar{}; } // OK

struct Foo {
    Foo() = delete;
    Foo(int);
};
int main() { Foo bar{}; } // Error

struct Foo {
private:
    Foo();
};
int main() { Foo bar{}; } // Error

```

## return initializer_list?
```c++
static int a = 1;
static int b = 2;

initializer_list<int> foo() {
    return {a, b} // copy first, return (assign by pointer)
}

int main() {
    auto p = foo(); // Error: dangling pointer
}

```

## void()
```c++
template <typename T>
T foo1() {
    return T();
}

template <typename T>
T foo2() {
    return T{};
}

template <typename T>
void foo3() {
    auto p = new T{};
    delete p;
}

void bar() {
    return void(); // OK
}

void baz() {
    return void{}; // Error
}
```
* std::invoke with return void

## Unicode support
```c++
char* \U0001f431 = "cat" // OK
char* üò∫ = "cat" // Error in GCC

int abc = 1;
int ab\u200c = 1;
int a\u200bc = 1;
int abc\u200 = 1;
```

## Lambda capture forwarding and universal reference
* [dis](https://stackoverflow.com/questions/46118564/alternative-for-stdbind-in-modern-c)
```c++
template<class T>
template<typename F, typename ...Args>
T Container<T>::addTask(F&& func, Args&&... args)
{
    container.emplace_back( [func = std::forward<F>(func),
                             args = std::make_tuple(std::forward<ARGS>(args)...)                                 ] 
                             ()  mutable // make mutable if you want to move the args in to func
                             {
                                 return std::apply(func, std::move(args));
                             });

    //.....
}
```

## Delete element in Cpp
* vector erase-remove
* remove_if
* [dis](https://stackoverflow.com/questions/38468844/erasing-elements-from-unordered-map-in-a-loop)
```c++
std::unordered_map<...> m;
auto it = m.begin();
while (it != m.end())
{
    if (pred(*it))
        it = m.erase(it);
    else
        ++it;
} // UB before Cpp14

std::unordered_map<...> mymap;
std::vector<decltype(mymap)::key_type> vec;
for (auto&& i : mymap)
    if (/*compare i*/)
        vec.emplace_back(i.first);
for (auto&& key : vec)
    mymap.erase(key);
```

## Nested using 
```c++
template <typename T>
template <typename U>
using P = std::is_same<T, U>; // Usable in gcc, failed in clang
                              // ill-formed

```

## vector.resize()
* [discuss](https://www.zhihu.com/question/65997834/answer/237364710)

## tie and tie
```c++
int a = 1, b = 2, c = 3;
std::tie(a, b, c) = {c, a, b};
cout << a << ' ' << b; // 3 3 well-defined?
```

## integer conversion
```c++
sizeof('a' + ' ') == sizeof(int) // true (C even char/bool literal = int)
-1L < 1U // long > int -> convert to long 1 | long == int -> convert to unsigned long 0
```

## default function argument
* ref: SuperNaiveCppLib/notes/CppCon2017/Notes

## launder
* make compiler remove const assumption
```c++
struct X {
    const int n;
    const double d;
};
X* p = new X{7, 8.8};
new (p) X{42, 9.9}; // place new value into p
int b = std::launder(p)->n; // OK, b is 42
int c = p->n; // undefined behavior!
double d = p->d; // undefined behavior!
```

## copy=elisionelision
* [discussion](https://stackoverflow.com/questions/48226247/why-isnt-move-constructor-elided-whenever-possible-with-make-x-functions)
* delay the process of turning prvalues into objects as long as possible.
* After C++17: prvalues themselves do not necessarily have to lead to the existence of objects (only if a ‚Äútemporary materialization‚Äù is necessary)
```c++
template <typename T>
X make_X(T&& arg) {
    return X(std::forward<T>(arg));
}

int main() {
    auto x1 = make_X(1); // elided
    auto x2 = X(X(1)); // elided
    //  binding a reference to a prvalue, apply temporary materialization conversion
    auto x3 = make_X(X(1)); // not elided
    X x4 = std::forward<X>(X(1)); // not elided
    X x5 = static_cast<X&&>(X(1)); // not elided
}
```
```c++
struct foo {
    foo() = default;
    foo(const foo&) = delete;
};

int main() {
    auto x = foo(); // prev-17: error! | 17: prvalue copy elision
}
```

## copy-and-swap without customize swap
```c++
class A {
    A(const A&) = default;
    A& operator(const A& rhs) {
        delete();
        A temp(rhs);
        std::swap(*this, temp); // infinite loop! will call copy ctor
        return *this;
    }  
};

```

## string literal is anonymous lvalue
```c++
const_cast<char*>("WTF")[0] = 'd'; // OK, though segmentation fault
true = false; // Failed, 1 is prvalue. <del>Python 2 will allow this</del>
```

## func-macro and identifier
```c++
class A {};

#define A(x) _

int main() {
    A a{}; // OK
    A(a{}); // Error
}
```

## Reference bind to different integer
```c++
char c = 'X';
int& i = c; // Error: promotion causes a prvalue
i = 'J';

void foo(long long int& r) {}
foo(i) // Error
foo(reinterpret_cast<long long int&>(i)) // Potential problem
// same as *reinterpret_cast<T*>(&(i))
```

## rdbuf()
```c++
std::cout << std::cin.rdbuf(); // consume
std::stringstream ss{"TEST"};
std::cin.rdbuf(ss.rdbuf()); // shallow copy
```

## sizeof?
* [discussion](https://stackoverflow.com/questions/46653406/why-does-sizeofmy-arr0-compile-and-equal-sizeofmy-arr0)
* `sizeof(arr)[0] === sizeof(arr[0])` (when `sizeof expression`)
```c++
static uint32_t my_arr[2];
static_assert(sizeof(my_arr) == 8, "");
static_assert(sizeof(my_arr[0]) == 4, "");
static_assert(sizeof(my_arr)[0] == 4, "");
static_assert(sizeof(int)*p == p * 4, ""); // will not parse as size((int*)p);
```

## std::string and SSO
* FBString
> Small strings (<= 23 chars) are stored in-situ without memory allocation. (align as 24 bytes data type)
> Medium strings (24 - 255 chars) are stored in malloc-allocated memory and copied eagerly.
> Large strings (> 255 chars) are stored in malloc-allocated memory and copied lazily.

## auto and private
```c++
class Foo {
    struct Bar { int i; };
public:
    Bar Baz() { return Bar(); } // Your problem...
};

class A {
    class B {};
public:
    typedef B user_t; // Because you choose it
};

int main() {
    Foo f;
    // Foo::Bar b = f.Baz();  // error
    auto b = f.Baz();         // ok
    std::cout << b.i;
}
```
* [discussion](https://stackoverflow.com/questions/13532784/why-can-i-use-auto-on-a-private-type/13532821#13532821)

## __has_trivial_copy
```c++
#include <type_traits>

using namespace std;

struct A {
    A(int v) : a(v) {}
    A(A&&) {a = 1;}
    // A(const A&) { a = 1; }
private:
    A(const A&) = delete;
    int a;
};

int main() {
    A a{1};
    // A b{a};
    cout << is_trivially_copyable<A>::value; // 0 user-defined move ctor
    cout << __has_trivial_copy(A); // 1
    cout << __is_pod(A); // 0
}
```
* before CWG-1734, trivial = implicit + delete

## ambiguous
```c++
1++1; // error
1+ +1 // 2
```

## push_back self element?
* [discussion](https://www.zhihu.com/question/66847606)
* [discussion](https://www.reddit.com/r/cpp/comments/vog1p/a_commonly_unknown_stdvector_pitfall/)
```c++
std::vector<X> vec;
vec.push_back(v.front()); // reallocation may happen before construct new element?
// emplace_back -> new space -> new element -> move/copy
```

## implicit function definition?
* only c90 allows this
```c
#include<stdio.h>

int main() {
    int a = sum(4,6);
    printf("%d",a);
    return 0;
}

int sum(int a,int b) {
    return a + b;
}
```

## injected class name
* The injected class name means that X is declared as a member of X, so that name lookup inside X always finds the current class, not another X that might be declared at the same enclosing scope.
```c++
class X { 
    using T = typename A::A; // However, this fails because A::A implies constructor // though constructor address should not be taken 
    // and constructor cannot be directly call by A::A(...))
};
X x1;
class X::X x2; // class X::X is equal to X
class X::X::X x3; // ...and so on...
```

## Inheritance function
```c++
struct X{ void func(); };
struct Y : public X{};
decltype(&Y::func) // void (X::*)()
```

## Dependent name
* [so]([Derived-template-class](https://stackoverflow.com/questions/4643074/why-do-i-have-to-access-template-base-class-members-through-the-this-pointer))
```c++
template <typename T>
class base {

protected:
    int x;
};

template <typename T>
class derived : public base<T> {

public:
    int f() { 
        return this->x; // base<T>::x || using base<T>::x
    }
};
```

## most vexing parse
```c++
void f(double adouble) {
  int i(int(adouble)); // function declaration int i(int adouble);
}
std::stringstream ss(std::string(argv[0])); // function declaration of ss (string argv[0] as array type)
```


## Attribute parsing
```c++
void f() {
  int y[3];
  y[[] { return 0; }()] = 1;    // error
  int i [[cats::meow([[]])]]; // OK
}
[[attr1]] class [[attr2]] c {...} [[attr3]] x [[attr4]], y;
// attr1 applies to variables x and y
// attr2 applies to class c
// attr3 applies to x's and y's types
// attr4 applies to variable x
```

## Operation associativity and precedence
```c++
a = 1, 2, 3; // Evaluated as (a = 1), 2, 3. Comma operator is left to right
if (c > b > a) // (c > b > a) is treated as ((c > b) > a), associativity of '>' is left to right.
a = b = c; // Evaluated as a = (b = c). = operator is right to left
int a;
(a = 1) = 2; // Builtin assignment returns T& lvalue
```

## Universal ? Rvalue ? Class template argument deduction ?
```c++
struct A {
    template <typename T>
    A(T&& v) {}
};

template <typename T>
struct B {
    B(T&& v) {};
};

int main() {
    int i = 233;
    auto&& v = i; // OK auto -> int&
    int&& m = i; // Error
    auto p = A{i}; // OK T -> int&
    auto q = B<int&>{i}; // OK T -> int&
    auto r = B{i}; // Error T -> int
    T& & p = ... // Error not such grammar
    // difference between class template deduction and template argument deduction
}
```

## Virtual memory exhausted
```c++
namespace std
{
  typedef long unsigned int size_t;
}

namespace std __attribute__ ((__visibility__ ("default")))
{
  template<typename _Tp, std::size_t _Nm>
    struct __array_traits
    {
      typedef _Tp _Type[_Nm];
    };

  template<typename _Tp, std::size_t _Nm>
    struct array
    {
      typedef std::__array_traits<_Tp, _Nm> _AT_Type;
      typename _AT_Type::_Type _M_elems;
    };
}

namespace std __attribute__ ((__visibility__ ("default")))
{
  template<size_t _Nw>
    struct _Base_bitset
    {
      typedef unsigned long _WordT;

      _WordT _M_w[_Nw];

      constexpr _Base_bitset() noexcept
      : _M_w() { }
    };

  template<size_t _Nb>
    class bitset
    : private _Base_bitset<((_Nb) / (8 * 8) + ((_Nb) % (8 * 8) == 0 ? 0 : 1))>
    {
    };
}

constexpr std::size_t N = 100000;
std::array<std::bitset<N>, N> elems; // The constexpr makes gcc to expand 100000 * 1563 wordT

int main() {}
```

## Bad variant
```c++
#include <variant>
#include <iostream>

using namespace std;

struct A{};
struct B{};
struct C{};
/*
struct D{};
struct E{};
struct F{};
struct G{};
struct H{};
struct I{};
struct J{};
struct K{};
struct L{};
struct M{};
struct N{};
struct O{};
*/

int main() {
  using T = variant<A, B, C/*, D, E, F, G, H, I, J, K, L, M, N, O*/>;
  T a{A{}};
  
  auto p = std::visit( 
    [](auto&& a, auto&&... args) -> T { return a; },
    a, a, a, a
  );
}
```
* another requirement: visitor of std::visit must be exhausive (some return type and can receive all kinds of input value)
* + g++ directly use get<0>, the hinting was soooooooooo sabi
* `variant<T, T>` is ill-formed but without diagnose
* [visit-overhead](https://www.reddit.com/r/cpp/comments/7pya5s/stdvisit_overhead/)

## Member specialized (such a dick)
```c++
template <class C> class X
{
public:
   template <class T> void get_as();
   template <> void get_as(); // Error! full-specialization only allowed in namespace scope
};

template <class C> template<>
void X<C>::get_as<double>() {} // Error! Explicitly specialized members need their surrounding class templates to be explicitly specialized as well.

template <> template<>
void X<int>::get_as<double>() {} // So why no just overload
```

## Asso container?
```c++
std::set<T> val{...};
struct MyClass {
    MyClass& operator<<(T& val); // #1
    template <typename U>
    MyClass& operator<<(U& val); // #2
};
for (auto& i: val) {
    MyClass{} << *i; // call #2, i -> const iterator
}
```

## Specialize namespace std
* [discussion](https://stackoverflow.com/questions/8513417/what-can-and-cant-i-specialize-in-the-std-namespace)

## Multiple declaration ? 
* [discussion](https://stackoverflow.com/questions/27895689/declarations-of-a-class-name-and-a-variable-with-the-same-name)

## Conversion Overload
* [discussion](https://stackoverflow.com/questions/47110853/call-to-conversion-operator-instead-of-converting-constructor-in-c17-during-ov)
```c++
#define PRETTY(x) (std::cout << __PRETTY_FUNCTION__ << " : " << (x) << '\n')

struct D;

struct C {
    C() { PRETTY(this);}
    C(const C&) { PRETTY(this);}
    C(const D&) { PRETTY(this);}
};

struct D {
    D() { PRETTY(this);}
    operator C() { PRETTY(this); return C();}
};

D d;
C c(d); // conversion or exact match ?
```

## Without struct/class
```c++
#include <iostream>
#include <vector>
#include <cstdint>
#include <functional>
#include <string>

using namespace std;

size_t hash(string s) {
    return hash<string>{}(s);  // ambiguous 
}
```

## unordered_map before 14
* The order of the elements that are not erased is preserved (this makes it possible to erase individual elements while iterating through the container) (since C++14)
* [discussion-and-solution](https://stackoverflow.com/questions/38468844/erasing-elements-from-unordered-map-in-a-loop)
```c++
std::unordered_map<...> m;
auto it = m.begin();
while (it != m.end())
{
    if (pred(*it))
        it = m.erase(it); // UB before 14
    else
        ++it;
}
```

## A real problem #1
What's wrong with this?
```c++
#include <iostream>
#include <vector>
#include <cstdint>
#include <string>
#include <unordered_map>
#include <functional>
#include <tuple>
#include <cassert>
#include <variant>
using namespace std;
template <std::size_t I, typename ...Args>
auto tuple_index_impl(size_t n, std::tuple<Args...>& tp) {
    // compile-time decide/check return type will not notice runtime branch end conditon
    // if you only write one if constexpr without else, still not notice
    // only if constexpr { ... } else { ... }
    // Also: the return type will deduce differently and failed
    if (I >= sizeof...(Args)) {
        throw std::out_of_range("Out of bound.");
        return {};
    } else {    
        if (n == I) {
            return std::get<I>(tp);
        }
        return tuple_index_impl<I + 1, Args...>(n, tp);
    }
}

template <typename ...Args>
auto tuple_index(size_t n, std::tuple<Args...>& tp) {
    return tuple_index_impl<0, Args...>(n, tp);
}


int main() {
    int i = 2;
    tuple<int, long, int> tp{1, 233, 2};
    /* Question 2: why variant failed (some type ill-formed)
    std::visit(
        [](long long&& c) { 
            std::cout << c << std::endl; 
        },
        tuple_index(i, tp)
    );
    */
}
```

## Short circuit ensure side-effect
* [discussion](https://stackoverflow.com/questions/3635722/short-circuit-evaluation-and-side-effects)
```c++
int main() {
    fork(); // (1 parent and 1 child) 
    fork() && fork() || fork(); // 4(both fork) + 4(both fork) + 2(only child do this fork)
    fork(); // x2 = 20
}
```

## C/C++ about pointer
```c++

#include  <stdio.h>

int main(void)
{
    int* x, *y;
    x = &(y); // fail in C++, valid in C
    y = &(x);
    printf("Hello, world!\n");
    return 0;
}
```

## Ranged-based-for-loop pitfall
* [proposal](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0614r0.html)
```c++
class T {
  std::vector<int> data_;
public:
  std::vector<int>& items() { return data_; }
  // ...
};

{
  T thing = f();
  for (auto& x : thing.items()) {
    // Note: ‚Äúfor (auto& x : f().items())‚Äù is WRONG
    mutate(&x);
    log(x);
  }
}
```
* The wrong is because 
```c++
auto&& temp = f().items(); // This will not extend lifetime! Causes dangling reference
```

## Non-dependent name
* [discussion](https://stackoverflow.com/questions/47261553/non-dependent-name-lookup-and-lambda)
```c++
template <class T>
struct Outer
{
    template <class U>
    void f();

    void bar(Outer outer) {
        [outer](){ outer.f<int>(); };
    }
};

int main() { }
```

## constexpr exchange (change in C++20 ABQ)
```c++
template<class T, class U = T>
constexpr T exchange(T& obj, U&& new_value) // without constexpr, won't work
{
    T old_value = std::move(obj);
    obj = std::forward<U>(new_value);
    return old_value;
}

struct S
{
  int* p;
  int n;
 
  constexpr S(S&& other)
    :p{std::exchange(other.p, nullptr)}
    ,n{std::exchange(other.n, 0)}
  {}
 
  constexpr S& operator=(S&& other) {
    p = std::exchange(other.p, nullptr); // move p, while leaving nullptr in other.p
    n = std::exchange(other.n, 0); // move n, while leaving zero in other.n
    return *this;
  }
};
```

## enable_shared_from_this
```c++
struct S
{
  shared_ptr<S> dangerous()
  {
     return shared_ptr<S>(this);   // don't do this!
  }
};

int main()
{
   shared_ptr<S> sp1(new S); // They are seperate
   shared_ptr<S> sp2 = sp1->dangerous();
   return 0;
}

struct S : enable_shared_from_this<S>
{
    // enable_shared_from_this<T> adds a private weak_ptr<T> instance to T which holds the 'one true reference count' for the instance of T.
    shared_ptr<S> not_dangerous()
    {
         return shared_from_this();
    }
}

int main()
{
   S *p = new S;
   shared_ptr<S> sp2 = p->not_dangerous();     // also bad.
}
```

## value with name is lvalue (except enumeration)

## ternary operator -> (l/rvalue)
```c++
int a=5, b=3;
++(a > b ? a : b);

int a=5;
double b=3;
++( a > b ? a : sb); // Error
```
* same type lvalue -> lvalue
* otherwise -> do common_type -> rvalue
> C - conditional-expression:
>> logical-OR-expression
>> logical-OR-expression ? expression : conditional-expression

> C++ - conditional-expression:
>> logical-OR-expression
>> logical-OR-expression ? expression : assignment-expression


## Abominable Function Types
* [proposal](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0172r0.html)
* `using abominable = void() const volatile &&;`
* you cannot decay it! const/volatile decorates `this`

## wtf is array type
```c++
void f(double x[volatile], const double y[volatile]);
void f(double * volatile x, const double * volatile y);
void f(double a[restrict static 3][5]); // the value of the actual parameter must be a valid pointer to the first element of an array with at least as many elements as specified by expression:
void fadd(double a[static restrict 10],
          const double b[static restrict 10])
{
    for (int i = 0; i < 10; i++) { // loop can be unrolled and reordered
        if (a[i] < 0.0) break;
        a[i] += b[i];
    }
}
```

#### Anonymous union with using
```c++
int main() {
    using T = union {
        int a;
    };
    // No valid a!
    union {
        int b;
    }
    b = 1; // OK
}
```

#### constexpr function parameter?
* [discussion](https://stackoverflow.com/questions/24580714/why-is-this-not-a-constant-expression)
* [discussion](https://stackoverflow.com/questions/44995196/static-member-access-in-constant-expressions/44996066)
```c++
constexpr int incr(int& n) {
  return ++n;
}
constexpr int g(int k) {
  constexpr int x = incr(k); // error: incr(k) is not a core constant
                             // expression because lifetime of k
                             // began outside the expression incr(k)
  return x;
}
constexpr int h(int k) {
  int x = incr(k); // OK: x is not required to be initialized with a core
                   // constant expression
  return x;
}
```

## deduce first
```c++
template <typename R = int, typename U>
R foo() {
    return -0.1;
}


int main() {
    foo<long long>(1); // return long long
}
```

## template default parameter
```c++
template<typename T1, typename T2 = int> class A;
template<typename T1 = int, typename T2> class A;
// the above is the same as the following: (same as function default parameter)
template<typename T1 = int, typename T2 = int> class A;

// not same
template<typename T = int> class X;
template<typename T = int> class X {}; // error
```

## Compare POD bytes
* [discussion](https://stackoverflow.com/questions/47437349/is-it-undefined-behavior-to-read-and-compare-padding-bytes-of-a-pod-type)

## Union + friend
* [clang::Type](https://www.zhihu.com/question/44213758/answer/262059049)

## operator-> chaining
```c++
myClass->myValue;
//--->
(myClass.operator-> ())->myValue;
```

## Lambda capture and compiler
* [twitter](https://twitter.com/pepper_chico/status/935192195329593344)
* [reddit](https://www.reddit.com/r/cpp/comments/7fl6zl/compilers_cant_agree_on_capture_type/)
```c++
#include <type_traits>

int main() {
    int x = 1;
    int& y = x;
    int&& z = static_cast<int&&>(x);

    [ ]{ static_assert(std::is_same<decltype( x ), int>::value, "A1"); };
    [=]{ static_assert(std::is_same<decltype( x ), int>::value, "A2"); };
    [&]{ static_assert(std::is_same<decltype( x ), int>::value, "A3"); };

    [ ]{ static_assert(std::is_same<decltype((x)), int&>::value, "B1"); };
    [=]{ static_assert(std::is_same<decltype((x)), const int&>::value, "B2"); };
    [&]{ static_assert(std::is_same<decltype((x)), int&>::value, "B3"); };

    [ ]{ static_assert(std::is_same<decltype( y ), int&>::value, "C1"); };
    [=]{ static_assert(std::is_same<decltype( y ), int&>::value, "C2"); };
    [&]{ static_assert(std::is_same<decltype( y ), int&>::value, "C3"); };

    [ ]{ static_assert(std::is_same<decltype((y)), int&>::value, "D1"); };
    [=]{ static_assert(std::is_same<decltype((y)), int&>::value, "D2"); };
    [&]{ static_assert(std::is_same<decltype((y)), int&>::value, "D3"); };

    [ ]{ static_assert(std::is_same<decltype( z ), int&&>::value, "E1"); };
    [=]{ static_assert(std::is_same<decltype( z ), int&&>::value, "E2"); };
    [&]{ static_assert(std::is_same<decltype( z ), int&&>::value, "E3"); };

    [ ]{ static_assert(std::is_same<decltype((z)), int&>::value, "F1"); };
    [=]{ static_assert(std::is_same<decltype((z)), int&>::value, "F2"); };
    [&]{ static_assert(std::is_same<decltype((z)), int&>::value, "F3"); };
}
```

## template template template template
```c++
template <typename T>
struct I {};

template <template <typename T> class U>
struct A {};

template <template <template <typename T> typename U> typename V, template <typename T> typename U>
void foo(V<U> wtf) {}

int main() {
    A<I> a;
    foo(a);
    return 0;
}
```

## set_value_at_exit
* If there is a use of a standard library object or function not permitted within signal handlers ([support.runtime]) that does not happen before ([intro.multithread]) completion of destruction of objects with static storage duration and execution of std‚Äã::‚Äãatexit registered functions ([support.start.term]), the program has undefined behavior. [‚ÄâNote: If there is a use of an object with static storage duration that does not happen before the object's destruction, the program has undefined behavior. Terminating every thread before a call to std‚Äã::‚Äãexit or the exit from main is sufficient, but not necessary, to satisfy these requirements. These requirements permit thread managers as static-storage-duration objects. ‚Äî‚Äâend note‚Äâ]
* They either all must exit or all must not touch the standard library after main() returns. http://eel.is/c++draft/basic.start.term#6 ‚Ä¶ detach() + Xxx_at_thread_exit == the program can no longer meet that requirement, ever.
```c++
#include <iostream>
#include <future>
#include <thread>
// UB on cppreference
int main()
{
    using namespace std::chrono_literals;
    std::promise<int> p;
    std::future<int> f = p.get_future();
    std::thread([&p] {
          std::this_thread::sleep_for(1s);
          p.set_value_at_thread_exit(9);
    }).detach();
 
    std::cout << "Waiting..." << std::flush;
    f.wait();
    std::cout << "Done!\nResult is: " << f.get() << '\n';
}
```

## numeric_limits on what?
* [discussion](https://stackoverflow.com/questions/47520847/c-why-does-numeric-limits-work-on-types-it-does-not-know)
* `/* non-specialized */	T();`
* you cannot specialize user-defined
* but you can use it??
```c++
#include <iostream>
#include <limits>
using namespace std;

// This is an int wrapper that defaults to 666 instead of 0
class A {
public:
    int x;
public:
    A() : x(666) {}
};

int main() {
    A a = std::numeric_limits<A>::max();
    A b = std::numeric_limits<A>::max();

    std::cout << a.x << "\n" << b.x; // 666 666
    // your code goes here
    return 0;
}
```

## /Wall and -Weverything
* [diag](https://gcc.godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(j:1,source:'%23include+%3Cvector%3E'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((g:!((h:compiler,i:(compiler:cl19_64,filters:(b:'0',binary:'1',commentOnly:'0',demangle:'0',directives:'0',execute:'1',intel:'0',trim:'0'),libs:!(),options:'/std:c%2B%2Blatest+/Wall',source:1),l:'5',n:'0',o:'x86-64+MSVC+19+2017+RTW+(Editor+%231,+Compiler+%231)',t:'0')),k:50,l:'4',m:50,n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1),l:'5',n:'0',o:'%231+with+x86-64+MSVC+19+2017+RTW',t:'0')),header:(),l:'4',m:50,n:'0',o:'',s:0,t:'0')),k:50,l:'3',n:'0',o:'',t:'0')),l:'2',n:'0',o:'',t:'0')),version:4)
* system headers are default excluded from warning sets

## auto deduce a reference
* [ref](https://blog.petrzemek.net/2017/12/08/when-auto-seemingly-deduces-a-reference-in-cpp/)

## forward declaring with trailing type
```c++
// This file is a "Hello, world!" in C++ language by GCC for wandbox.
#include <iostream>
#include <cstdlib>

template <typename T, typename... Args>
auto TrailingMake(Args&&... args) -> std::enable_if_t<std::is_constructible_v<T, decltype(args)...>, T>; // That's a gcc bug

template <typename T, typename... Args>
auto TrailingMake(Args&&... args) -> std::enable_if_t<std::is_constructible_v<T, decltype(args)...>, T>
{
    return T{ std::forward<Args>(args)... };
}

template <typename T, typename... Args>
std::enable_if_t<std::is_constructible_v<T, Args...>, T> NormalMake(Args&&... args);

template <typename T, typename... Args>
std::enable_if_t<std::is_constructible_v<T, Args...>, T> NormalMake(Args&&... args)
{
    return T{ std::forward<Args>(args)... };
}

int main()
{
    const auto a = TrailingMake<int>(1);
    const auto b = NormalMake<int>(2);
    (void)a, (void) b;
}
```

## Base constructor order
* [gotw](http://www.gotw.ca/gotw/080.htm)
* First, the most derived class's constructor calls the constructors of the virtual base class subobjects. Virtual base classes are initialized in depth-first, left-to-right order.
* Next, direct base class subobjects are constructed in the order they are declared in the class definition.
* Next, (nonstatic) member subobjects are constructed, in the order they were declared in the class definition.
* Finally, the body of the constructor is executed.
```c++
class B1 { };
class V1 : public B1 { };
class D1 : virtual public V1 { };

class B2 { };
class B3 { };
class V2 : public B1, public B2 { };
class D2 : public B3, virtual public V2 { };

class M1 { };
class M2 { };

class X : public D1, public D2 { M1 m1_; M2 m2_; };
/*

B1      B1   B2
|      |   /
|      |  /
|      | /
V1      V2    B3
|       |   /
|v     v|  /
|       | /
D1       D2
\     /
    \   /
    \ /
    X

first, construct the virtual bases:
construct V1:
    B1::B1()
    V1::V1()
construct V2:
    B1::B1()
    B2::B2()
    V2::V2()

next, construct the nonvirtual bases:
construct D1:
    D1::D1()
construct D2:
    B3::B3()
    D2::D2()

next, construct the members:
M1::M1()
M2::M2()

finally, construct X itself:
X::X()
*/
```

## Accumulation
```c++

#include <vector>
#include <numeric>

int main(){
  std::vector<double> vec{1.1,2.2,3.3,4.4,5.5};
  return std::accumulate(begin(vec), end(vec), 0); // 15
  return std::accumulate(begin(vec), end(vec), 0.0); // 16
}
```

## int/size_t as index
* [discussion](https://twitter.com/lefticus/status/940608074426941445)

## define INT_MIN
* [discussion](http://0xffffff.org/2013/01/17/11-c-standard-int-min/)
```c++
#define INT_MAX 2147483647
#define INT_MIN -INT_MAX-1 // avoid promotion
```

## WTF lambda capture
* Right. More generally, a mention of a reference is not an odr-use if the reference is initialized by a constant expression, and captures are only necessary to permit odr-use.
* [discussion](https://www.reddit.com/r/cpp/comments/7k03as/just_as_you_thought_you_understood_c/)

## Always use auto
```c++
constexpr auto auto‚Äã()
{
  return 1;
}

typedef decltype(auto‚Äã()) auto‚Äã‚Äã;
const auto‚Äã‚Äã auto‚Äã‚Äã‚Äã = auto‚Äã();

template <typename auto‚Äã‚Äã‚Äã‚Äã>
constexpr auto auto‚Äã‚Äã‚Äã‚Äã‚Äã() {
    return auto‚Äã‚Äã‚Äã;
}

template <typename auto‚Äã‚Äã‚Äã‚Äã, typename auto‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã, typename... auto‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã>
constexpr auto auto‚Äã‚Äã‚Äã‚Äã‚Äã() {
    return auto‚Äã‚Äã‚Äã + auto‚Äã‚Äã‚Äã‚Äã‚Äã<auto‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã, auto‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã...>();
}

int main()
{
  constexpr auto auto‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã = auto‚Äã‚Äã‚Äã‚Äã‚Äã<auto‚Äã‚Äã,auto‚Äã‚Äã,auto‚Äã‚Äã,auto‚Äã‚Äã,auto‚Äã‚Äã,auto‚Äã‚Äã>();
  constexpr auto auto‚Äã‚Äã‚Äã‚Äã = auto‚Äã‚Äã‚Äã‚Äã‚Äã<auto‚Äã‚Äã,auto‚Äã‚Äã,auto‚Äã‚Äã,auto‚Äã‚Äã,auto‚Äã‚Äã,auto‚Äã‚Äã,auto‚Äã‚Äã>();
  return auto‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã‚Äã*auto‚Äã‚Äã‚Äã‚Äã; 
}
```
* [discussion](https://twitter.com/RichardKogelnig/status/943497972481953792)

## Deduce right hand function
```c++
template <typename T>
void func(T&){
}

int main(){
    void (*p)(int&) = func;//or &func
    return 0;
}
```

#### mem_fn
* `template <typename R, typename T> auto mem_fn(R T::* pm)`
* regard function as member
* `mem_fn<int&()>(&X::ApointerReturnint&)`

#### thread and exception safety
* [ref](https://akrzemi1.wordpress.com/2012/11/14/not-using-stdthread/)
```c++
auto run = []
{
    // if an exception escapes here std::terminate is called
};
std::thread thread(run);

// notice that we do not detach the thread
// if an exception escapes here std::terminate is called

thread.join();
// end of scope

auto run = []() -> T // T may be void as above
{
    // may throw
    return /* some T */;
};

auto launched = std::async(run);
// launched has type std::future<T>

// may throw here; nothing bad happens

// expression has type T and may throw
// will throw whatever was originally thrown in run
launched.get();
```

#### async and scale
* [discussion](https://bartoszmilewski.com/2011/10/10/async-tasks-in-c11-not-quite-there-yet/)
* [n3451](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3451.pdf)
* If the std::future obtained from std::async is not moved from or bound to a reference, the destructor of the std::future will block at the end of the full expression until the asynchronous operation completes, essentially making code such as the following synchronous:
```c++
std::async(std::launch::async, []{ f(); }); // temporary's dtor waits for f()
std::async(std::launch::async, []{ g(); }); // does not start until f() completes

auto f1 = async( []{ f(); } ); // this is ok
auto f2 = async( []{ g(); } );
```
* [discussion-2](https://stackoverflow.com/questions/16296284/workaround-for-blocking-async)
* 
```c++
int main() 
{
    std::cout << "Main thread id: " << std::this_thread::get_id() 
        << std::endl;
    std::vector<std::future> futures;
    for (int i = 0; i < 20; ++i)
    {
        auto fut = std::async([]
        {
            std::this_thread::sleep_for(std::chrono::seconds(1));
            std::cout << std::this_thread::get_id() << " ";
        });
        futures.push_back(std::move(fut));
    }
    std::for_each(futures.begin(), futures.end(), [](std::future & fut)
    {
        fut.wait();
    });
    std::cout << std::endl;
}
// 2 4 3 6 5 7 1 1 1 1 1 1 1 1 1 1 1 1
```

#### Not a real atomic
* All atomic types except for std::atomic_flag may be implemented using mutexes or other locking operations, rather than using the lock-free atomic CPU instructions. Atomic types are also allowed to be sometimes lock-free, e.g. if only aligned memory accesses are naturally atomic on a given architecture, misaligned objects of the same type have to use locks.
* The C++ standard recommends (but does not require) that lock-free atomic operations are also address-free, that is, suitable for communication between processes using shared memory.

## mutex in destructor
```c++
Foo::~Foo {
    std::lock_guard<std::mutex> lk{m_mtx};
}

void Foo::update() {
    std::lock_guard<std::mutex> lk{m_mtx};
}

void thread1() {
    delete x;
    x = nullptr;
}

void thread2() {
    if (x) {
        x->update();
    }
}

// since m_mtx is destructed, undefined behavior
```

## C significant characters
* [discussion](https://stackoverflow.com/questions/18290165/whats-the-exact-role-of-significant-characters-in-c-variables)

## . vs ->
* a.b can be non-lvalue
* a->b must be lvalue

## vector ctors
* noexcept move => copy => move
* [discussion](https://stackoverflow.com/questions/8001823/how-to-enforce-move-semantics-when-a-vector-grows/8864895#8864895)

## prvalue vs. xvalue & elision
* [discussion](https://stackoverflow.com/questions/48174588/how-do-we-test-if-an-expression-of-a-certain-type-can-be-invoked-with-a-prvalue)

## terminate vs. unexpected
* When uncaught exception is occur, terminate is called.
* When unexpected exception is occur, unexpected is called.
```
void my_terminate() {
    std::cerr << "my terminate handler";
    std::exit(0);
}

void my_unexpected() {
    std::cerr << "my unexpected handler";
    std::exit(EXIT_FAILURE);
}

void function() throw() // no exception in this example, but it could be another spec
{
    throw std::exception();
}

int main(int argc, char* argv[])
{
    std::set_terminate(my_terminate);
    std::set_unexpected(my_unexpected);
    try {
        function();
    } catch (const std::logic_error&) {
    }
    return 0;
}
```

## Default but no aggregate?
```c++
struct A
{
  int a = 3;
  int b = 3;
};

A a{0,1}; // Not allowed in C++11, allowed in C++14
```
* [discussion](https://stackoverflow.com/questions/27118535/c11-aggregate-initialization-for-classes-with-non-static-member-initializers)

## UB on i=i++?
* [discussion](https://stackoverflow.com/questions/4968854/is-i-i-truly-a-undefined-behavior)

## Use int?
* [discussion](https://stackoverflow.com/questions/48729384/is-there-still-a-reason-to-use-int-in-c-code)
```c++
double get(const double* p, int k) {
  return p[k];
}
/*
movslq %esi, %rsi
vmovsd (%rdi,%rsi,8), %xmm0
ret
*/
double get(const double* p, std::ptrdiff_t k) {
  return p[k];
}
/*
vmovsd (%rdi,%rsi,8), %xmm0
ret
*/
```

## function-try-block
>> Every catch-clause in the function-try-block for a constructor must terminate by throwing an exception. If the control reaches the end of such handler, the current exception is automatically rethrown as if by throw;. The return statement is not allowed in any catch clause of a constructor's function-try-block.

## uninitialize_copy vs. copy
* std::copy overwrites existing objects in the destination range using operator=. 
* std::uninitialized_copy creates new objects in the destination range using placement new. If there happen to be existing objects in the destination range, you can get memory corruption.
* [ref](https://social.msdn.microsoft.com/Forums/vstudio/en-US/e0bd2dd9-173d-4894-b39a-b5b08e96d70e/difference-between-stdcopy-and-stduninitializedcopy?forum=vcgeneral)

## Overload comma operator
* [discussion](https://stackoverflow.com/questions/5602112/when-to-overload-the-comma-operator/5602136#5602136)

## valarray, what's that
* [discussion](https://stackoverflow.com/questions/1602451/c-valarray-vs-vector)

## enum variable undefined
* [discussion](https://stackoverflow.com/questions/6842799/enum-variable-default-value)
```c++
enum color { red, yellow, green = 20, blue };
color col = red;
int n = blue; // n == 21




enum SomeEnum {  
    EValue1 = 1,  
    EValue2 = 4,
    EValue3 = 15,  
};
SomeEnum e; // e is 0
int i;      // i is 0

int main() {
    SomeEnum f;
    cout << e << " " << i; //prints 0 0 
    cout << f; // undefined
}
```

## Call parent method
```
void child::method() {
    parent::method();
    c.parent::method();
}
```

## Must be visible
```
void foo() { // 1
    cout << "WTF";   
}



template <typename T>
void foo(T t) { // 2
    cout << "Small\n";   
}


template <typename T, typename ...Args>
void foo(T t, Args... args) { // 3
    cout << "Large\n";
    foo(args...);
}

// call foo(1, 2, 3, 4)
// 123 => LLLS
// 132 => LLLW
// 213 => LLLS
```

## is_nothrow_copy_constructible<runtime_error> false ?
* [discussion](https://stackoverflow.com/questions/35039927/are-the-copy-constructor-and-copy-assignment-of-stdruntime-error-noexcept)
```
An inheriting constructor (12.9) and an implicitly declared special member function (Clause 12) have an exception-specification. If f is an inheriting constructor or an implicitly declared default constructor, copy constructor, move constructor, destructor, copy assignment operator, or move assignment operator, its implicit exception-specification specifies the type-id T if and only if T is allowed by the exception-specification of a function directly invoked by f‚Äôs implicit definition; f allows all exceptions if any function it directly invokes allows all exceptions, and f has the exception-specification noexcept(true) if every function it directly invokes allows no exceptions.
```

## Take address of std::free
```c++
std::unique_ptr<char, decltype(std::free) *>
    t_copy { strdup(t), std::free };
```
* [discussion](https://stackoverflow.com/questions/27440953/stdunique-ptr-for-c-functions-that-need-free/)
* std::free in not guaranteed to be void(void*)
* you shall not specialize std function templates
* Only in newest N4741:
> Let F denote a standard library function (20.5.5.4), a standard library static member function, or an instantiation of a standard library function template. Unless F is designated an addressable function, the behavior of a C++ program is unspecified (possibly ill-formed) if it explicitly or implicitly attempts to form a pointer to F . [ Note: Possible means of forming such pointers include application of the unary & operator (8.5.2.1), addressof (23.10.11.1), or a function-to-pointer standard conversion (7.3). ‚Äî end note ] Moreover, the behavior of a C++ program is unspecified (possibly ill-formed) if it attempts to form a reference to F or if it attempts to form a pointer-to-member designating either a standard library non-static member function (20.5.5.5) or an instantiation of a standard library member function template
* ACCU 2018 Lightning talks - Wednesday

## constexpr function calling inside class
```c++
class TestClass1{ 
public:
    static constexpr int getInt(){return 0;};
    static constexpr int y = getInt();//why it's wrong?
    TestClass1(){}
};
```
* [CWG-1626](http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1626)
* [discussion](https://stackoverflow.com/questions/11522399/constexpr-initializing-static-member-using-static-function%EF%BC%9A)
* [discussion](https://www.v2ex.com/t/460939#reply14)

## sizeof(struct {}) ?
* [discussion](https://stackoverflow.com/questions/1626446/what-is-the-size-of-an-empty-struct-in-c)

## sizeof(Cls::foo) ?
* [Why C++ Member Function Pointers Are 16 Bytes Wide](http://lazarenko.me/wide-pointers/)
* [Pointers to member functions are very strange animals](https://blogs.msdn.microsoft.com/oldnewthing/20040209-00/?p=40713)
* [discussion](https://stackoverflow.com/questions/29607359/size-of-pointer-to-member-function-varies-like-crazy)
* + Under MSVC compiler (/vmg, /vmb options)
* + The size of a pointer-to-member-function of a class that uses only single inheritance is just the size of a pointer.
* + The size of a pointer-to-member-function of a class that uses multiple inheritance is the size of a pointer plus the size of a size_t.
* + The size of a pointer-to-member-function can change depending on the class
* + Casting a function pointer can change its size

## return ways
* [discussion](https://www.youtube.com/watch?v=9mWWNYRHAIQ)
```c++
std::string get_string(const bool b) {
    if (b) {
        return "A";
    } else {
        return "B";
    }
    // return b ? "A" : "B"; // cmov and will incur extra strlen
    // ret = "A"; // will force compiler default construct
}
```

## inherited member function pointer type
```c++
struct parent
{
    int parent_method(int);
};

struct foo : parent
{
    int some_method(int);
};

abi::__cxa_demangle(typeid(&foo::parent_method).name(), NULL, NULL, NULL); // int (parent::*)(int)
```