# 面经合集



## 2019 Summer - 2020 Summer Intern

|   Company    |        Open        |        Submitted        |        Status         |                                                              |
| :----------: | :----------------: | :---------------------: | :-------------------: | ------------------------------------------------------------ |
|    Akuna     | :heavy_check_mark: | :heavy_check_mark: 海投 |       :x: OA拒        |                                                              |
|    Amazon    | :heavy_check_mark: | :heavy_check_mark: 海投 | :checkered_flag: OA3  |                                                              |
|     AMD      |                    |                         |                       |                                                              |
|    Apple     | :heavy_check_mark: | :heavy_check_mark: 海投 |                       |                                                              |
|    Airbnb    | :heavy_check_mark: | :heavy_check_mark: 海投 |                       |                                                              |
|    Asana     | :heavy_check_mark: | :heavy_check_mark: 内推 |      :x: 简历拒       |                                                              |
|  Atlassian   | :heavy_check_mark: | :heavy_check_mark: 海投 |      :x: 简历拒       |                                                              |
|  Bloomberg   | :heavy_check_mark: | :heavy_check_mark: 海投 |      :x: 简历拒       |                                                              |
|    C3.ai     | :heavy_check_mark: | :heavy_check_mark: 海投 |      :x: 简历拒       |                                                              |
|   Cadence    | :heavy_check_mark: | :heavy_check_mark: 海投 |                       |                                                              |
|    Cisco     | :heavy_check_mark: | :heavy_check_mark: 海投 |                       |                                                              |
|   Citadel    | :heavy_check_mark: | :heavy_check_mark: 海投 |      :x: 简历拒       |                                                              |
|  Databricks  | :heavy_check_mark: | :heavy_check_mark: 海投 |                       |                                                              |
|   De Shaw    | :heavy_check_mark: | :heavy_check_mark: 海投 |      :x: 简历拒       |                                                              |
|   Dropbox    | :heavy_check_mark: | :heavy_check_mark: 海投 |                       |                                                              |
|     Ebay     |                    |                         |                       |                                                              |
|   Facebook   | :heavy_check_mark: | :heavy_check_mark: 内推 |      :x: 简历拒       |                                                              |
|    Google    | :heavy_check_mark: | :heavy_check_mark: 内推 |                       |                                                              |
|     Hulu     | :heavy_check_mark: | :heavy_check_mark: 海投 |                       |                                                              |
|     IBM      | :heavy_check_mark: | :heavy_check_mark: 海投 |                       |                                                              |
|    Indeed    |                    |                         |                       |                                                              |
|    Intel     | :heavy_check_mark: | :heavy_check_mark: 海投 |      :x: 简历拒       |                                                              |
|   LinkedIn   | :heavy_check_mark: | :heavy_check_mark: 内推 |      :x: 简历拒       |                                                              |
|     Lyft     | :heavy_check_mark: | :heavy_check_mark: 内推 |                       |                                                              |
|  Microsoft   | :heavy_check_mark: | :heavy_check_mark: 海投 |                       |                                                              |
|   MongoDB    | :heavy_check_mark: | :heavy_check_mark: 海投 |                       |                                                              |
|   Mozilla    | :heavy_check_mark: | :heavy_check_mark: 海投 |                       |                                                              |
|    Nvidia    | :heavy_check_mark: | :heavy_check_mark: 海投 |      :x: 简历拒       |                                                              |
|    Ocient    | :heavy_check_mark: | :heavy_check_mark: 海投 | :checkered_flag: 电面 |                                                              |
|    Oracle    | :heavy_check_mark: | :heavy_check_mark: 海投 |                       |                                                              |
|    Paypal    | :heavy_check_mark: | :heavy_check_mark: 海投 |                       |                                                              |
|   PingCAP    |                    |                         |                       | https://angel.co/company/pingcap-1/jobs                      |
|  Pinterest   |                    |                         |                       |                                                              |
| Pure Storage | :heavy_check_mark: | :heavy_check_mark: 海投 |  :checkered_flag: OA  |                                                              |
|   Red Hat    | :heavy_check_mark: | :heavy_check_mark: 海投 |                       | https://careers-redhat.icims.com/jobs/search?ss=1&searchKeyword=software+intern&searchCategory=17505 |
|    Reddit    |                    |                         |                       |                                                              |
|  Robinhood   | :heavy_check_mark: | :heavy_check_mark: 海投 |                       |                                                              |
|  Salesforce  | :heavy_check_mark: | :heavy_check_mark: 海投 |                       |                                                              |
|    Slack     | :heavy_check_mark: | :heavy_check_mark: 海投 |                       |                                                              |
|    Tesla     | :heavy_check_mark: |                         |                       |                                                              |
| ThoughtWorks |                    |                         |                       | https://www.thoughtworks.com/careers/jobs                    |
| TripAdvisor  | :heavy_check_mark: | :heavy_check_mark: 海投 |                       |                                                              |
|    Twitch    |                    |                         |                       |                                                              |
|   Twitter    | :heavy_check_mark: | :heavy_check_mark: 海投 |  :checkered_flag: OA  |                                                              |
|  Two Sigma   | :heavy_check_mark: | :heavy_check_mark: 内推 |                       |                                                              |
|     Uber     | :heavy_check_mark: | :heavy_check_mark: 海投 |      :x: 简历拒       |                                                              |
|    VMWare    |                    |                         |                       |                                                              |
|     Yelp     | :heavy_check_mark: | :heavy_check_mark: 内推 |                       |                                                              |
|              |                    |                         |                       |                                                              |

* [zacklight](https://zacklight.com/internships/)
* [Job Hunting](https://www.notion.so/Job-Hunting-Public-a01874eb0eb54af3a4c0a03447b42534)
* [1p3a](https://www.1point3acres.com/bbs/thread-542247-1-1.html)
* 改简历 - Backend





## 2 Sigma

* Missing words

  * 双指针

  * > 一开始用hashmap存remove word会超时
    > 从左往右扫就ok

* Substring

  * 从后往前遍历
  * 优化aaaaaaaaaab





## Amazon

* 2019.8 高频题
  
  * ![1566864725814](D:\OneDrive\Pictures\Typora\1566864725814.png)
  
* 二维矩阵横竖都有序，输入一个数返回坐标，没有返回（-1， -1)
  * 二维二分 / 二维双指针, lc原题
  * [leetcode 240 search a 2d matrix](https://leetcode.com/problems/search-a-2d-matrix-ii/)
  
* 输入连通图里的所有边，输出critical connection，即移除该边图不连通‍‍‌‌‍‌‌‍‍‌‍‌‌‍‍‍‍‌‍
  * 求无向连通图的割点
  
  * ![1567052650935](D:\OneDrive\Pictures\Typora\1567052650935.png)
  
  * [连通图强连通分量-割点-缩点/Tarjan](https://www.cnblogs.com/stxy-ferryman/p/7779347.html)
  
  * [求无向连通图的割点](https://www.cnblogs.com/en-heng/p/4002658.html)
  
  * ```c++
    void helper(int u, vector<bool> &visited, vector<pair<int,int>> &res, list<int> *adj, vector<int> &disc, vector<int> &low, vector<int> &parent) {
        static int time = 0;
        visited[u] = true;
        disc[u] = low[u] = ++time;
        list<int>::iterator i;
        for (i = adj[u].begin(); i != adj[u].end(); i++) {
            int v = *i;
            if (!visited[v]) {
                parent[v] = u;
                helper(v, visited, res, adj, disc, low, parent);
                low[u] = min(low[u], low[v]);
                if (low[v] > disc[u]) {
                    res.push_back(make_pair(u, v));
                }
            }
            else if (v != parent[u]) {
                low[u] = min(low[u], disc[v]);
            }
        }
    }
     
    vector<pair<int, int>> criticalConnection(int numOfServers, int numOfConnections,vector<pair<int, int>> connections) {
        list<int> *adj = new list<int>[numOfServers+1];
        for (int i = 0; i < connections.size(); i++) {
            adj[connections[i].first].push_back(connections[i].second);
            adj[connections[i].second].push_back(connections[i].first);
        }
        vector<bool> visited(numOfServers+1, false);
        vector<int> disc(numOfServers+1, 0);
        vector<int> low(numOfServers+1, 0);
        vector<int> parent(numOfServers+1, 0);
        vector<pair<int, int>> res;
        for (int i = 0; i < numOfServers; i++) {
            if (!visited[i]) {
                helper(i, visited, res, adj, disc, low, parent);
            }
        }
        return res;
    }
    
    ```
  ```
    
  * ![1567054062693](D:\OneDrive\Pictures\Typora\1567054062693.png)
  
  * > 第一，当图为空的时候，记得要返回空List
    > 第二，当找到一个 Critical connection 的时候，记得把两个 vertex 的 id 排一下序再存入list里，比如 6 和 7 之间的 bridge 应该是（6， 7）, 你如果寸入的是 (7,  6) 就会报错
    > 第三，函数返回值是List<PairInt>, 这个是亚麻自定义的 da‍‍‌‌‍‌‌‍‍‌‍‌‌‍‍‍‍‌‍ta structure, 记得处理一下就行，我记得定义如下：
    > public class PairInt {
    >         int first;
    >         int second;
    >         public PairInt(int first, int second) {
    >                 this.first = first;
    >                 this.second = second;
    >         }
    > }
  ```
  
* 变形jump game 给两个array 第一个代表位置 第二个代表能跳的步数 可以往后 也可以往前跳 求能不能跳到最后

* 一个array里找最小和第二小的数 要求比较次数不高于O(n)+O(logn)

* [leetcode 572 subtree-of-another-tree](https://leetcode.com/problems/subtree-of-another-tree/)

* > 两个HashMap，第一个Map的key是用户名(String), value是一个String List，里面是video game的名字。第二个Map的key是video game的类型(String), value也是一个String List, 存的是这个类型的所有的video game的名字。要求是返回一个Map，key是用户名，value是一个List，这个List里存用户最喜欢的video game的类型，可以一个可以多个。判断是不是最喜欢的类型是通过看这个用户的video games里哪种类型最多。
  >
  > 比如说类型map是空的，你还是要返回一个跟用户map size一样的map，只不过每个value都是空的list，而不能就返回一个空的map

  * >   给两个map，第一个是string 人名 ：vector<string> 书， 第二个是string 类型 ：vector<string> 书
    > 需要返回一个map， string 人名 ： vector<string> 最喜欢看的类型
    > // map1 {"Tom" : ["booka", "bookb"]; 'Jack" : ["booka","bookc","bookd"];}
    > // map2 {"happy" : ["booka", "bookd"]; "sad" : ["bookb","bookc"];}
    > // res { "Tom" : ["happy", "sad"]; "Jack" : ["happy"];}
    >
    > 这里jack看了A C D,但是A D都是happy，两票，C是sad，一票，所以只有happy最喜欢的类型是happy。
    > 需要注意的edge case有三种。 第一种是map1是空的，直接返回一个空map。第二种情况是map2是空的，这个时候要把人名加进去，但是每个人名的value是个空vector。第三种情况是map1只有人名，value里的vector是空，这个时候需要把人名存进去，value是空的。  
  
* 飞机上放音乐还是影片，两个加起来刚好等于一个值而且要包含所有符合的结果里面最长一个电影的。返回一对int
  
  * map O(N)
  
* 飞机来回程利用飞机max range最大的组合。输入是两个二维list，包含index和range
  
  * 暴力
  
* 给定n个文件， 和一个list of file size， 求minimum time to merge file

  * 周赛题, pq
  * -> 哈夫曼树构造

* 复制链表带random： lc 138

* lc 937

* 2 sum closest

* lc 105

* Remove Obstacle(背景：机器人去除障碍物) 

  * BFS搞定

* Give a computer with total K memory space, and an array of foreground tasks and background tasks the computer need to do. Write an algorithm to find a pair of tasks from each array to maximize the memory usage. Notice the tasks could be done without origin order.

* [leetcode 105 construct-binary-tree-from-preorder-and-inorder-traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

* ![img](D:\OneDrive\Pictures\Typora\055224mfllrmllfrfanfzg.png)

  * BFS

* ![img](D:\OneDrive\Pictures\Typora\055226wabirlmpprnzdddo.png)

  * pq 原题

* OOP题
  
  * 设计parking lot
  
* 改正题
  * printPattern even odd类型，跟其他面经一样，for loop missing {}
  * reverse array, len += 1  corrected by len -= 1
  * sort array in decending order, max > arr[j]  corrected by max < arr[j]
  * replace values, i <= len corrected by i < len, the same as j <= len
  * print character pattern, 这道题少大括号或者把 char ch = 'a'移到 for loop 里
  * countOccurrence 返回Value在Array里面出现的次数 while loop里面缺少i++
  * CheckGrade 两个else if里的‘||’改为‘&&’
  * count‍‍‌‌‍‌‌‍‍‌‍‌‌‍‍‍‍‌‍Digits 加一句temp=num; 然后把return里所有的的num改为temp, 这样num就不会被改变了
  
* [OA题](https://drive.google.com/file/d/1pdvVVKoCxtSuerds95iZPAH8k3oEdBr1/)

* [Amazon Online Assessment Questions](https://leetcode.com/discuss/interview-question/344650/Amazon-Online-Assessment-Question)

  * 双序列找最接近和 -> 排序双指针, 注意重复值
  * [Path With Maximum Minimum Value](https://www.cnblogs.com/Dylan-Java-NYC/p/11297106.html): 最大堆, BFS
  * [Distance Between Nodes in BST](https://leetcode.com/discuss/interview-question/376375): 利用BST, 要么是同祖先两段, 要么递归左右子树
  * [Find Pair With Max Appeal Sum](https://leetcode.com/discuss/interview-question/355698): 维护`A[i]-i`和`A[i]+i`的最大值 (某周赛题)
  * [Min Cost to Connect All Nodes](https://leetcode.com/discuss/interview-question/356981): Kruskal MST + Union-Find
  * [Count substrings with exactly K distinct chars](https://leetcode.com/discuss/interview-question/370157) + [Substrings of size K with K distinct chars](https://leetcode.com/discuss/interview-question/370112): 滑动窗口
  * [Subtree with Maximum Average](https://leetcode.com/discuss/interview-question/349617): 同时记录Count和Avg/Sum, (某周赛题)
  * [Partition Labels](https://leetcode.com/problems/partition-labels): 维护每个字符的最远距离和当前子串的最远距离, 相等则切割

* [小土刀Amazon](https://wdxtub.com/interview/14520850399861.html)







## Akuna

* 3-card poker

  * ![1566575332614](D:\OneDrive\Pictures\Typora\1566575332614.png)

* >  给你一个国际象棋的棋盘，两个knight的棋子，一黑一白，两个都只能走“L”字形。黑和白两个棋子都由你自己来控制，黑白不断轮流着走，一个一轮。
  >      定义一个函数，input是黑白初始位置坐标，output是黑追上白或者白追上黑的最小可能的步数和他们走过的square的个数。
  
* 视为一个棋子BFS, [马走日](https://blog.csdn.net/jacketinsysu/article/details/52613937)
  
  * > >   首先国际象棋的棋盘是黑白相间的，按题目给出的走法，每走一步必然会变颜色。那么可以看初始条件里两个棋子颜色是否相同，只要计算(x1+y1-x2-y2)%2就可以。如果颜色相同，两个棋子一共需要走偶数步，否则是奇数步。这样就可以判断题目给的条件是否能够满足。
    > >
    > > 接下来是算最少步数，这基本就用暴力了，不知道有没有更好的办法。
    > > 首先在所有棋盘上的方格标上0，白色标+1，黑色标-1。白色先走，可以落8个点，如果落点在棋盘内，继续判断。如果这个点已经标了一个负数，那么说明黑色上一步已经可以走到这一点了，此时算一下有多少个这样的点，计算步数，返回，结束。如果没标记（标记为0）就标上2，说明白色走2-1=1步可以到达。如果已经标记了一个正数，说明之前白色就可以到达这一点，所以不再标记（标记的都对应最短步数）。黑色每走一步就减1。这样一直到棋子相遇为止。
    > > 也可以一个棋子不动，只动另一个棋子。不过这样时间空间复杂度似乎变高了。  
    > >
    > > https://www.1point3acres.com/bbs/interview/akunacapital-quant-466472.html
  
* 找是否有共线三点

  * 转化成斜率 + 共点, [max-points-on-a-line](https://leetcode.com/problems/max-points-on-a-line/)
  * 对每个点, 求所有斜率 `(dx/gcd, dy/gcd)`, 如果相同, 表示共线. 考虑垂直和重合
  
* > 给一个 N*N 的数组 （地图），数组元素是 0, 1, -1。 0是冰面，1是可以落脚的雪堆，-1是坑。给定一个你的初始点（在雪堆上），你可以向上下左右任意方向滑行，直到碰到下一个雪堆，或离开边界（获救），或者掉坑里（挂了）。还给定了你的爱犬的初始坐标，也是在一个雪堆上。问能否带着你的狗顺利滑出边界获救。

  * BFS?

* ![1566573168009](D:\OneDrive\Pictures\Typora\1566573168009.png)

  * 模拟?

* 已知一个矩阵，找出满足“该点数值小于周围相邻数值”的点的数值，输出最小的三个

  * 暴力

* 已知一个由positive number组成的array，和一个整数k，输出一个tuple表示subarray的区间，使该subarray的和与k最接近

  * 2 pointer?

* 已知一个‘+’‘-’组成的字符串，每一次要整体flip连续k个字符。问最少需要几次可以全获得‘+’，不能获得的话 输出-1

  * 贪心 最左边0一定要翻转, 滑动窗口维护flip % 2
  * [leetcode-965 minimum-number-of-k-consecutive-bit-flips](https://leetcode.com/articles/minimum-number-of-k-consecutive-bit-flips/)

* palindrome dates

  * ![img](D:\OneDrive\Pictures\Typora\085707q02xl8i8x80d3yee-1566573436713.png)

* 2-36进制转换

* 找出围绕最多的点的个数：一条绸带长度为k，给你一堆点的坐标，问这条带子能围绕住最多多少个点

  * ![1566612774476](D:\OneDrive\Pictures\Typora\1566612774476.png)

  * > 应该先算最小的圈，一个个扩大，直至绳子不能容纳

* 斐波那契数列：给你一个数a，一个值n，问你a能否=不同的n个斐波那契数之和

  * [zhihu](https://www.zhihu.com/question/68360587)
  * dp

* 给一个array（升序排列）和k，k在arrary中，array.size>1。求包含<=k的subarray的median。如果是even，取mean

  * 前缀和+2 pointer?

* 题目说给一个grid，开关灯问题，给first coordinates和turn off lights的coordinates，关灯和（－1，0）／（－1，－1）相连的也关灯。最后看开着的灯数量。

  * > LAMP， 给你矩阵的长宽，起始点，和相对位置，从起始点开始关灯，所有相连位置都要关灯，最后返回亮灯的数目

* 有m个多边形，每个多边形有n条边，每条边可以有k中染色方式，求从多边形中取出两个多边形，染色相同的概率，另如果rotate之后染色相同也算相同，但不能翻折

* 求standard deviation

* 求一个数能否是三个数的乘积

* 将一个矩阵逆时针转九十度

* 将后序表达式转化为中序表达式输出，例如ab+变为a+b, 另外在保证运算正确的情况下括号要最少， 比如 (a+b)+(c+d)括号就是多余的。

  * 栈

* [valid-parentheses](https://leetcode.com/problems/valid-parentheses/)

  * 栈

* 找出三角形内到顶点‍‍‌‌‍‌‌‍‍‌‍‌‌‍‍‍‍‌‍最近的整数点

  * 面积法
  * 叉乘法, 绕三角形一圈 判断同向

* [leetcode-719 find-k-th-smallest pair distance](https://leetcode.com/problems/find-k-th-smallest-pair-distance/)

* ![1566606715107](D:\OneDrive\Pictures\Typora\1566606715107.png)

* 射线与球相交

  * [ref](https://www.jianshu.com/p/1b008ed86627)

* ![1566611011575](D:\OneDrive\Pictures\Typora\1566611011575.png)

  * >   LZ解答：
    >     设期望收益是EX
    >     最后一次，EX = 1/6*（1+2+...+6）=3.5
    >     倒数第二次，扔出4 5 6则放弃下一轮，扔出1 2 3，则选择扔最后一轮，因为最后一轮的期望收益是3.5大于1 2 3
    >     EX = 1/6 * (4+5+6) + 3/6 * 3.5 = 4.25
    >     倒数第三次，扔出5 6则放弃下一轮，扔出1 2 3 4，则选择扔下一轮，因为下一轮的期望收益是4.25大于1 2 3 4
    >     EX = 2/6 *（5+6）+ 4/6 * 4.25 = 14/3
    >
    >    公平的定价应‍‍‌‌‍‌‌‍‍‌‍‌‌‍‍‍‍‌‍该等于玩家的期望收益，所以定价为14/3  

* ![1566611076113](D:\OneDrive\Pictures\Typora\1566611076113.png)

* [最小树形图/有向MST](https://www.cnblogs.com/xzxl/p/7243466.html)

* ![1566612645586](D:\OneDrive\Pictures\Typora\1566612645586.png)

* ![1566612692412](D:\OneDrive\Pictures\Typora\1566612692412.png)

  * 贪心交换?

* Hash Table From Even Stream

  * > 根据一个List of strings重建hashtable，并记录最后一个操作的时间，明显是数据库相关的

* Event Stream From Binary WAL

  * > 给了一个连续byte stream的write ahead log（所有的log都concat在一起），要求用这个重建符合第一题格式的List of strings，并且要根据第一个key sorted。
    >
    > format大致是fixed length时间+fixed length操作类型+fixed length存key length+key length长度的byte（比如key length是10那这个field就读10个byte）+fixed length存value length+value length的value（和key那个field一样）。
    > 挂点：一共有三种log的类型，第三种的byte str‍‍‌‌‍‌‌‍‍‌‍‌‌‍‍‍‍‌‍eam比其他两种要短。我测试的时候发现每次处理完第三种的log去处理下一个log的时候都会超出两个index。一开始认为是sort的问题，发现以后没有调试出问题时间不够没改对。

  * [java](https://www.evernote.com/shard/s705/client/snv?noteGuid=c439dfb0-4759-4056-91da-77cc28efa40f&noteKey=597e8c3f37bcde0d&sn=https%3A%2F%2Fwww.evernote.com%2Fshard%2Fs705%2Fsh%2Fc439dfb0-4759-4056-91da-77cc28efa40f%2F597e8c3f37bcde0d&title=akuna%2Boa%2B2020)

* ![1566613049627](D:\OneDrive\Pictures\Typora\1566613049627.png)

  * 滑动窗口? 

  * [leetcode 713-subarray product less than K](https://leetcode.com/problems/subarray-product-less-than-k/)

  * ```c++
    // 尝试先窗口size优化, 然后二分优化, 挂, 复杂度应该是 log^2n
    // 这题到底是不是contiguous/monotonically increasing subarray?
    long countSubarrays(vector<int> numbers, int k) {
        int N = numbers.size();
        long long p = 1;
        long cnt = 0;
        int times = N;
        if (numbers[0] != 1) {
            times = log(N) / log(numbers[0]);
        } else {
            times = log(N) / log(numbers[1]) + 1;
        }
        vector<long long> pmul(N + 1, 1);
        for (int i = 0; i < N; ++i) {
            pmul[i + 1] = pmul[i] * numbers[i];
            if (numbers[i] <= k)
                ++cnt;
        }
        // 去除N
        if (pmul[N] <= k) {
            return N * (N - 1);
        } else if (times == N) {
            times = N - 1;
        }
        long long l = 0;
        long long r = N - 1;
        for (int i = times; i >= 2; --i) {
            // 不用重置l, l肯定只会增大
            r = N - i;
            // 二分查找i长窗口, upper_bound
            while (l <= r) {
                int mid = (l + r) / 2;
                long long tmp = pmul[mid + i] / pmul[mid];
                if (tmp > k) {
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            }
            cnt += l;
        }
        return cnt;
    }
    ```
    
  * ```c++
    // leetcode解法, O(N), 注意到left最多被移动N次
    int numSubarrayProductLessThanK(vector<int>& nums, int k) {
        int product = 1;
        size_t len = nums.size();
        size_t left = 0;
      int result = len;
        for (size_t right = 0; right < len; ++right)
        {
            product *= nums[right];
            while (product >= k && left <= right) {
                product /= nums[left++];
            }
            result += right - left;
        }
        return result;
    }
    
    ```
  
  * 
  
* ![1566613337835](D:\OneDrive\Pictures\Typora\1566613337835.png)

  * > 可以发现所有数字的质因数个数不会超过7个
    > 一开始先计算1~sqrt(100000)的所有质数
    > 利用质数表对minRotor~maxRotor的所有数字做质因数分解
    > 再利用排容原理计算出每个数字对minRotor~maxRotor的互质数量(ci)
    > 最后答案为sum(ci^(‍‍‌‌‍‌‌‍‍‌‍‌‌‍‍‍‍‌‍rotorCount-1)) minRotor <= i <= maxRotor
    
  * ```c++
    // 容斥法求非互质个数
    int notcoprimes(int m, const vector<int>& factors) {
        vector<int> ps;
        ps.push_back(-1);
        for (int f : factors) {
            int N = ps.size();
            for (int j = 0; j < N; ++j) {
                ps.push_back(ps[j] * f * (-1));
            }
        }
        int sum = 0;
        for (int i = 1; i < ps.size(); ++i) {
            sum += m / ps[i];
        }
        return sum;
    }
    
    int m = 1e9 + 7;
    
    long long modpow(long long base, int exp, int modulus) {
      base %= modulus;
      long long result = 1;
      while (exp > 0) {
        if (exp & 1) result = (result * base) % modulus;
        base = (base * base) % modulus;
        exp >>= 1;
      }
      return result;
    }
    
    int calculateTotalRotorConfiguration(int rotorCount, int minRotorValue, int maxRotorValue) {
        vector<int> primes;
        int sum = 0;
        if (maxRotorValue == 1) return 0;
        // 求素数表
        for (int i = 2; i <= maxRotorValue; ++i) {
            bool div = true;
            for (int j : primes) {
                if (i % j == 0) {
                    div = false;
                    break;
                }
            }
            if (div) {
                primes.push_back(i);
            }
        }
        // 对每个数求互质个数, 则为互质个数^(rc - 1)
        for (int i = minRotorValue; i <= maxRotorValue; ++i) {
            vector<int> factors;
            for (int j : primes) {
                if (i % j == 0)
                    factors.push_back(j);
            }
            int ncp1 = notcoprimes(minRotorValue - 1, factors);
            int ncp2 = notcoprimes(maxRotorValue, factors);
            int cp = maxRotorValue - ncp2 - (minRotorValue - 1 - ncp1);
            sum += modpow(cp, rotorCount - 1, m);
            sum %= m;
        }
        return sum % m;
    }
    ```
    
  * 
  
* ![1566613527344](D:\OneDrive\Pictures\Typora\1566613527344.png)

* ![1566614523446](D:\OneDrive\Pictures\Typora\1566614523446.png)

  * 



## Facebook

* 2019.8 高频题
  
* ![1566864770149](D:\OneDrive\Pictures\Typora\1566864770149.png)
  
* 二叉搜索树范围内的和

  * [leetcode 938 range-sum-of-bst](https://leetcode.com/problems/range-sum-of-bst/)

    * 因为是BST, 直接判断左子树右子树

    * ```c++
      class Solution {
      public:
          int rangeSumBST(TreeNode* root, int L, int R) {
              if (!root)
                  return 0;
              if (root->val < L)
                  return rangeSumBST(root->right, L, R);
              if (root->val > R)
                  return rangeSumBST(root->left, L, R);
              return rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R) + root->val;
          }
      };
      ```

    * 或者DFS序LCA

  * 







## Google

* 2019.8 高频题
  
* ![1566864701116](D:\OneDrive\Pictures\Typora\1566864701116.png)
  
* > Strictly Smaller：给两个strings A and B，返回一个int数组。数组里面的每个数值记录了针对每个B里的substring，A里有多少个partition是strictly smaller than B的。比如说A = "qaaazx aab ba", B = "aaa bb"，则返回[2,1]，因为A里面的"aab", "ba" 的a的出现频率都是小于B的"aaa"的，所以第一位是1；同理，"aab"和"ba" 都是strictly smaller than "bb"的，所以第二位填2. str‍‍‌‌‍‌‌‍‍‌‍‌‌‍‍‍‍‌‍ictly smaller指的是拿每个string里的最小字符(lexicographical order)出现次数做对比.

  * 题目准确率存疑

* > Largest Continguous Subarray：给一个数组A和一个长度K，返回最大的长度为K的连续数组，其中最大的定义是比如A = [3,6,2,9,7,6], K = 5, 一共会出现两个subarray a=[3,6,2,9,7], b=[6,2,9,7,6]，第二个数组大于第一个数组，因为他们在index为0的时候就不相等且a[0] < b[0]。要看的就是俩俩数组对比下来他们第一次不相等的时候是谁在那个index上的value比较大

  * 

* > 有一个显示屏，给定长度和宽度。同时有一行只含字母的字符串，每个字符的大小与其对应的font-size有关，font-size范围从0到100。
  > Question: font-size最大取多少，这个显示屏可以完全展示整个字符串。
  > API：GetWidth(char a, int font_size); GetHeight(int font_size);
  > NOTE：对于相同font-size的字母，高度一样宽度不同。一个字母在一行放不下后，必须放到第二行，不能半个在a行，半个在a+1行。

  * 

* > 有一个matrix，其中只有1和0，1为可通过，0为不可通过。
  > Question: 找出最短的一条路径，从matrix的第一行能到最后一行，并输出路径。
  > NOTE: 无路可走，输出空的vector。多条路最短，输出任意一条。
  > Follow Up: matrix 变为n和0，n为可通过的cost，0为不可通过，问题一样。

  * Dijkstra

* 给一个binary tree, 其中有节点会乱指, 将乱指的节点指向空, 有不同种可能时, 返回深度最小的binary tree

  * 对根BFS, 然后统计特异点 (指向已访问的点), 再对每个特异点做BFS, 如果能连通所有点且深度更小, 更新

* merge intervals

  * [leetcode 56 merge-intervals](https://leetcode.com/problems/merge-intervals/)

* 离原点第K近的点

* 二叉树和最大的层数

* 用卡牌组成给定的伤害

* 椅子数目（meeting room2）

* 奇偶跳

* 减法减string

* 打字string的总距离

* LeetCode 551. Student [att](http://redirect.viglink.com/?key=a1aa544c3b328def412653f9fc432107&u=https%3A%2F%2Fwww.att.com%2Fshop%2Fwireless%2Fdevices%2Fcellphones.html)endance Record I

* LeetCode 552. Student Attendance Record II

* Reorder an array according to given indexes

  * [geeksforgeeks](https://www.geeksforgeeks.org/reorder-a-array-according-to-given-indexes/)
  * O(1) extra space，不能修改 index[]

* Filling rectangles with  integer-sided squares

  * [square](Filling rectangles with integer-sided squares)

* Rank of an element in a stream

  * [geeksforgeeks](https://www.geeksforgeeks.org/rank-element-stream/)

* > 有一个水桶容量是C，每朵花需要的水量是Ai(1<=i<=N)，i=0是补水站
  > 需要依序浇水，如果水桶剩余水量不够就必须i=0补水
  > 一开始在i=0，问浇完所有花的最少移动步数
  > sample: 
  > C = 3, A = [2, 2, 1, 1, 2]
  > 移动路径: 0->1->0->2->3->0->4->5 total=13

  * DP, `dp(i, C) = min(dp(i - 1, j)) + 1`, `dp(i, j) = min(dp(i - 1, j + a[i]))`
* ![img](D:\OneDrive\Pictures\Typora\131706n30kdwwo7tj8btdw.png)
  
* > 有N个domino，每个上有两个点数(1~6)，用Ai, Bi表示
  > 每次操作可以翻转一个domino，也就是交换Ai, Bi
  > 问最少几个操作可以让A或B都一样，不行输出-1
  > sample:
  > A = [1, 2, 1, 3], B = [1, 1, 2, 1], ans = 1

  * > 先统计一下每个数字出现的次数判断是否有解
    > 有解的话就直接数一下要翻几次就好

  * ![img](D:\OneDrive\Pictures\Typora\131713m6tofmzvmsmmm7hv-1567667496188.png)

  * 贪心, 计数一下A[0], B[0]在双边出现的次数

  * [leetcode 1007 minimum-domino-rotations-for-equal-row](https://leetcode.com/problems/minimum-domino-rotations-for-equal-row/)
  
  * ```c++
    class Solution {
    public:
        int minDominoRotations(vector<int>& A, vector<int>& B) {
            int top = A[0];
            int bot = B[0];
            int Atop = 0;
            int Abot = 0;
            int Btop = 0;
            int Bbot = 0;
            for (int i = 0; i < A.size(); ++i) {
                if (A[i] != top && B[i] != top) top = 0;
                if (A[i] != bot && B[i] != bot) bot = 0;
                Atop += A[i] == top;
                Abot += A[i] == bot;
                Btop += B[i] == top;
                Bbot += B[i] == bot;
            }
            if (!top && !bot) return -1;
            return min(A.size() - max(Atop, Abot), B.size() - max(Btop, Bbot));
        }
  };
    ```
  
* > 给一堆公路的名称, 比如i-95, us-97, i-99... 现在开始road trip， 司机是个强迫症，选择的每条公路必须遵循一定规律，就是两条公路的数值diff必须相同。比如从i-95开始，下一条选了97，那么再下条就只能选99。或者也可以i-80, i-85, i90这样。问最长的路径的diff的sum。 第一个例子就是6， 第二个例子是15

  * DFS + MEMO / DP

* 带过期timestamp的hashmap

* > 给一堆文件directory，让根据输入输出所有directory的parent directory。 比如“a/b/c”, “a/b”, “foo/bar” 那么对应的输出是a/b/c : {a/b, a}  a/b/ : {a}, foo/bar : "". 注意a/b/c 有parent directory 是因为可以从输入里找到a/b和a， foo/bar的是空因为输入里并不存在foo。

  * > 就‍‍‌‌‍‌‌‍‍‌‍‌‌‍‍‍‍‌‍是建一个hashmap<String, Set<String>>， 先把所有的输入都加入到map里，然后再尝试分割每个路径， 比如，a/b/c分割成 a和 a/b，如果map里存在这些分割后的路径，就说明父路径存在。

* 设计操作系统升级

* Given a binary tree, where an arbitary node has 2 parents i.e two nodes in the tree have the same child. Identify the defective node and remove an extra edge to fix the tree.

  * ```java
    public static TreeNode removeEdgeBT(TreeNode root) {
    	return removeEdgeBT(root, new HashSet<>());
    }
    
    private static TreeNode removeEdgeBT(TreeNode node, Set<TreeNode> seen) {
    	if (node == null || !seen.add(node)) return null;
    	node.left = removeEdgeBT(node.left, seen);
    	node.right = removeEdgeBT(node.right, seen);
    	return node;
    }
    
    // BST
    public static TreeNode removeEdgeBST(TreeNode root) {
        return removeEdgeBST(root, null, null);
    }
    
    private static TreeNode removeEdgeBST(TreeNode node, Integer min, Integer max) {
        if (node == null) return null;
        if ((min != null && node.val <= min) || (max != null && node.val >= max)) return null;
        node.left = removeEdgeBST(node.left, min, node.val);
        node.right = removeEdgeBST(node.right, node.val, max);
        return node;
    }
    ```

* > 二维迷宫，-1表示墙，0表示路。可以往上下左右四个方向走。返回从‍‍‌‌‍‌‌‍‍‌‍‌‌‍‍‍‍‌‌左上角到右下角的最短路径。如果路径不存在，返回空array。
  > 比如
  > 0 -1 -1
  > 0  0  -1
  > -1 0  0
  > return: [(0, 0), (1, 0), (1, 1), (2, 1), (2, 2)]
  >
  > follow up:
  > 把迷宫里一些0改成正整数，代表加油站里有多少油。
  > 每走一步需要消耗一格油，走到加油站的时候可以把加油站的油都加上（油箱没有上限）。返回从左上角到右下角的最短路径。

  * > 这道题的第一问和followup似乎都应该用bfs，bfs找最短路径比dfs更合适啊。bfs做followup也能keep 一个gas变量，keep一个visited

* > input是一段python code，要求输出这段code里所有的‍‍‌‌‍‌‌‍‍‌‍‌‌‍‍‍‍‌‌comment
  > 比如
  > def foobar():
  >
  >    \# comment1
  >
  >    print('hello word')
  >
  >    \# comment 2
  >
  >    return
  >
  > return: [" comment1", "comment2"]
  >
  > corner case很多很麻烦，比如#这个字符在""里或者''里
  > #这个字符在""" """里

* leetcode 833

  * 倒着搜一遍

* > 大概是说 一堆人参加一个比赛, 要排名次，但是每个人只知道排在自己前面的人是谁，要求输出所有选手的名次。

  * 拓扑图

* > 给了一张图，一开始以为二叉树，后来才明白是一个类似于字典树的结构，有多个分叉，每条边上写了一个数字(不是写在root的圈里)，问从 root到 ‍‍‌‌‍‌‌‍‍‌‍‌‌‍‍‍‍‌‌leaf 路径上所有数字的和最大值。 就是recursion + trie

* 

* [Google-Online-Assessment-Questions](https://leetcode.com/discuss/interview-question/352460/Google-Online-Assessment-Questions)



## LinkedIn

* 2019.8 高频题
  * ![1566864797153](D:\OneDrive\Pictures\Typora\1566864797153.png)



## Microsoft

* 2019.8 高频题
  * ![1566864823397](D:\OneDrive\Pictures\Typora\1566864823397.png)



## PureStorage

* happy number: 哈希表或者双指针

  * ```c++
    class Solution {
    public:
        int digitSquareSum(int n) {
            int sum = 0, tmp;
            while (n) {
                tmp = n % 10;
                sum += tmp * tmp;
                n /= 10;
            }
            return sum;
        }
    
        bool isHappy(int n) {
            int slow, fast;
            slow = fast = n;
            do {
                slow = digitSquareSum(slow);
                fast = digitSquareSum(fast);
                fast = digitSquareSum(fast);
            } while(slow != fast);
            if (slow == 1) return 1;
            else return 0;
        }
    };
    ```

* 虚函数表

  * [虚函数](https://www.evernote.com/shard/s260/client/snv?noteGuid=dfc7453b-e50f-46c0-b223-196bead364a9&noteKey=c41f1cea8f38c1802d1941338b03d375&sn=https%3A%2F%2Fwww.evernote.com%2Fshard%2Fs260%2Fsh%2Fdfc7453b-e50f-46c0-b223-196bead364a9%2Fc41f1cea8f38c1802d1941338b03d375&title=PureStorage%2B%25E7%2594%25B5%25E9%259D%25A2%25E9%259D%25A2%25E7%25BB%258F)

* ![1569296774173](D:\OneDrive\Pictures\Typora\1569296774173.png)

  * 树状数组

* [onsite](https://www.evernote.com/shard/s260/client/snv?noteGuid=af17167e-0389-43fb-952a-5b9a35dde171&noteKey=b555f82aaa5d1d2c9b353194335a1b62&sn=https%3A%2F%2Fwww.evernote.com%2Fshard%2Fs260%2Fsh%2Faf17167e-0389-43fb-952a-5b9a35dde171%2Fb555f82aaa5d1d2c9b353194335a1b62&title=PureStorage%2B%25E6%2598%2582%25E5%25A1%259E%25E7%2589%25B9)

* [multithread](https://www.evernote.com/shard/s260/client/snv?noteGuid=a01e5b26-d3eb-44c0-8ef4-01086605f675&noteKey=da31dd196df57906d67ab4ea189304f1&sn=https%3A%2F%2Fwww.evernote.com%2Fshard%2Fs260%2Fsh%2Fa01e5b26-d3eb-44c0-8ef4-01086605f675%2Fda31dd196df57906d67ab4ea189304f1&title=PureStorage%2BMultithread%2BPhone%2BQuestion)

* 3sum

* grid最短路径 (0, 1, 9) BFS

* number of palindrome substring

  * ```java
    public class Solution {
        int count = 0;
       
        public int countSubstrings(String s) {
            if (s == null || s.length() == 0) return 0;
            
            for (int i = 0; i < s.length(); i++) { // i is the mid point
                extendPalindrome(s, i, i); // odd length;
                extendPalindrome(s, i, i + 1); // even length
            }
            
            return count;
        }
       
        private void extendPalindrome(String s, int left, int right) {
            while (left >=0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            count++; left--; right++;
        }
    }
    ```

* 判断锁

  * ```java
    public int checkValid(String[] events) {
        if (events == null || events.length < 1) {
            return 0;
        }
    
        int step = 1;
        // Use LIFO(stack) data structure to monitor lock and unlock process
        // In Java, we prefer to use Deque interface instead of using Stack interface
        Deque<String> lockStack = new ArrayDeque<>();
        // use set to determine if only one unique lock at this time
        Set<String> records = new HashSet<>();
    
        for (String l : events) {
            String[] array = l.split(" ");
            if (array[0].equals("ACQUIRE")) { //When string is ACQUIRE, push to stack
                if (records.contains(array[1])) {
                    return step;
                }
                records.add(array[1]);
                lockStack.push(array[1]);
            } else { // when string is RELEASE, pop from stack
                if (lockStack.isEmpty() || !lockStack.peek().equals(array[1])) {
                    return step;
                }
                lockStack.pop();
                records.remove(array[1]);
            }
            step++;
        }
        if (!lockStack.isEmpty()) {
            return events.length + 1;
        }
        return 0;
    }
    ```

* [Multiple choices](https://www.1point3acres.com/bbs/thread-218233-1-1.html)

* 







## Twitter

* restock 仓库问题, 有一个list,每个数字对应供应商每个 item 能提供的货物量, 还有一个 target 是你要采购的目标, 进货只能从list 的第 0 个开始连续买, 买到达到 target 的量就停止, 如果全买完都没到达 target 也只能停止, 返回你所购买的货物的量和 target 差的绝对值
  
  * 前缀和, 二分
  
* weird faculty, 有n 个问题和对应的答对答错情况, 答对+1 分,答错-1 分, 有两个人你和你朋友, 你可以选择回答 top k 个问题, 你朋友答剩下的 n-k 个问题, 求你可选择的最小 k, 使你的分数大于你朋友的分数

* 给两个字符串 a,b,‍‍‌‌‍‌‌‍‍‌‍‌‌‍‍‍‍‌‍ 计算一个字符串a经过多少次 modification 就可以变成字符串 b 的 anagram
  
  * 计数, 修改次数就是计数差的一半
  
* 给一系列喷泉,问最少用几个就能覆盖所有范围, 一排喷灌系统，每个系统有自己的cover range，要求得出最少启动多少个系统就能够浇灌整个公园

  * DP

  * 最少区间完全覆盖

  * > 令s表示已经覆盖到的区域。再剩下的区间中找出所有左端点小于等于当前已经覆盖到的区域s并且右端点大于等于s的区间，取右端点最大的区间加入，直到已经覆盖全部的区域。?

* [leetcode 496 next greater element i](https://leetcode.com/problems/next-greater-element-i/)
  
  * 单调栈维护next greater存到unordered_map中
  
* partition array，题目老长了，其实就是能整分 并且 出现次数不大于k

  * counter一步到位

* twitter new office design

  * 写个helper算相邻俩table的max hashtag weight 数学问题 两步

* game events

  * >  存了排序 题目不难但是像做阅读理解
    > rule和case有矛盾也是gg 一定要仔细看规则
    > 两层map+sort做的
    > 但‍‍‌‌‍‌‌‍‍‌‍‌‌‍‍‍‍‌‌有一个case没有过 可能看漏了哪里的规则细节
    > 懒得想了就直接交了

* 调整`vector<int>`, 使得没有重复数字，并且sum最小

* efficient job processing

  * double task之后就是背包原型 dp解决

* 返回vector里能组成的pair数，使其abs差值==k

* Final discounted price，看了半天就是first next‍‍‌‌‍‌‌‍‍‌‍‌‌‍‍‍‍‌‍ less or equal
  
  * 单调栈
  
* ![1567558596856](D:\OneDrive\Pictures\Typora\1567558596856.png)

* ![1567558631165](D:\OneDrive\Pictures\Typora\1567558631165.png)

  * lazy tag

* ![1567558682781](D:\OneDrive\Pictures\Typora\1567558682781.png)

  * DP?

* ![1567558693610](D:\OneDrive\Pictures\Typora\1567558693610.png)

  * 对长度扫一遍? n^3
  * DP: `dp(i + 1, j) + dp(i, j - 1) + 1 - dp(i - 1, j - 1) or dp(i + 1, j) + dp(i, j - 1) + 1 - dp(i - 1, j - 1)` (判断Palindrome只需要`P(i - 1, j - 1)`且`s[i] == s[j]`), 相当于同时做最长和所有 n^2
  * [Manacher O(N) ?](https://cp-algorithms.com/string/manacher.html#toc-tgt-6)

* 排队问题, pq + 计数

* 三色花, dp

* 区间最优, 对结束时间贪心, 类似non-overlapping intervals

* combinational sum ii

* 如何把array分成长度为k的subsequence，保证每个元素只使用一次，每个结果里面没有内部重复的element

  * 数一下count基本上就能解决。

* 如何从x1, y1 -> x2, y2。只支持(x,y) -> (x+y, y) or (x,y)->(x,x+y)两种操作

  * 辗转相减

* Parking dilemma: 给一个array，里面的每个元素代表一辆汽车的坐标，现在要给汽车搭雨棚，问能罩住k辆车的雨棚的最小长度 input: [2, 10, 8, 17], k=3，ret‍‍‌‌‍‌‌‍‍‌‍‌‌‍‍‍‍‌‌urn 9

  * 二分

* leetcode 256

* 给n个桌子的位置（数字）和这n个桌子的高，每个桌子中间的每个gap可以放hashtag，要求把所有gap放上hashtag且每个gap的hashtag高度最多比两边桌子多1‍‍‌‌‍‌‌‍‍‌‍‌‌‍‍‍‍‌‌（可以低于桌子），求最高的hashtag，要注意两个桌子一样高的情况

* ![img](D:\OneDrive\Pictures\Typora\080824ylkhts7ytqpll8z0.png)

* ![img](D:\OneDrive\Pictures\Typora\080825oyhomrhhyg68h6tc.png)





## Uber

* 2019.8 高频题
  * ![1566864844651](D:\OneDrive\Pictures\Typora\1566864844651.png)



## VMWare

* 找第K大数

* m*n矩阵，激光从左上角走到右下角的所有路径
  
  * 如果有障碍物的所有路径
  
* 树的左右‍‍‌‌‍‌‌‍‍‌‍‌‌‍‍‍‍‌‍最长距离

* >  是reviews和几类keywored, 在reviews里找这几类keywords出现的次数

* > Reachable Business， 真的是楼主自己脑残不知道说什么好，做面经时写了个复杂有环版本，然后题目输入不一样，楼主还在试图建图，完全没有意识到是无环的其实很简单

* ![1567759143847](D:\OneDrive\Pictures\Typora\1567759143847.png)

* 



## Yelp

* 