# 面经合集



## 2019 Summer - 2020 Summer Intern

|  Company   |        Open        |        Submitted        |   Status   |
| :--------: | :----------------: | :---------------------: | :--------: |
|   Akuna    | :heavy_check_mark: | :heavy_check_mark: 海投 |  :x: OA挂  |
|   Amazon   | :heavy_check_mark: | :heavy_check_mark: 海投 |            |
|   Apple    | :heavy_check_mark: | :heavy_check_mark: 海投 |            |
|   Airbnb   | :heavy_check_mark: |                         |            |
|   Asana    |                    |                         |            |
| Bloomberg  |                    |                         |            |
|  Citadel   | :heavy_check_mark: | :heavy_check_mark: 海投 | :x: 简历挂 |
| Databricks | :heavy_check_mark: | :heavy_check_mark: 海投 |            |
|  Dropbox   | :heavy_check_mark: |                         |            |
|    Ebay    |                    |                         |            |
|  Facebook  | :heavy_check_mark: | :heavy_check_mark: 内推 | :x: 简历挂 |
|   Google   |                    |                         |            |
|    IBM     | :heavy_check_mark: | :heavy_check_mark: 海投 |            |
|   Indeed   |                    |                         |            |
|  LinkedIn  |                    |                         |            |
|    Lyft    | :heavy_check_mark: |                         |            |
| Microsoft  | :heavy_check_mark: | :heavy_check_mark: 海投 |            |
|   Nvidia   |                    |                         |            |
|   Paypal   | :heavy_check_mark: |                         |            |
|  Red Hat   |                    |                         |            |
|   Reddit   |                    |                         |            |
| Salesforce | :heavy_check_mark: |                         |            |
|   Slack    |                    |                         |            |
|   Twitch   |                    |                         |            |
|  Twitter   | :heavy_check_mark: | :heavy_check_mark: 海投 |            |
| Two Sigma  | :heavy_check_mark: | :heavy_check_mark: 内推 |            |
|    Uber    |                    |                         |            |
|   VMWare   |                    |                         |            |
|    Yelp    | :heavy_check_mark: |                         |            |
|            |                    |                         |            |

* [zacklight](https://zacklight.com/internships/)
* [Job Hunting](https://www.notion.so/Job-Hunting-Public-a01874eb0eb54af3a4c0a03447b42534)











## Amazon

* 2019.8 高频题
  * ![1566864725814](D:\OneDrive\Pictures\Typora\1566864725814.png)
* 







## Akuna

* 3-card poker

  * ![1566575332614](D:\OneDrive\Pictures\Typora\1566575332614.png)

* >  给你一个国际象棋的棋盘，两个knight的棋子，一黑一白，两个都只能走“L”字形。黑和白两个棋子都由你自己来控制，黑白不断轮流着走，一个一轮。
  >      定义一个函数，input是黑白初始位置坐标，output是黑追上白或者白追上黑的最小可能的步数和他们走过的square的个数。
  
* 视为一个棋子BFS, [马走日](https://blog.csdn.net/jacketinsysu/article/details/52613937)
  
  * > >   首先国际象棋的棋盘是黑白相间的，按题目给出的走法，每走一步必然会变颜色。那么可以看初始条件里两个棋子颜色是否相同，只要计算(x1+y1-x2-y2)%2就可以。如果颜色相同，两个棋子一共需要走偶数步，否则是奇数步。这样就可以判断题目给的条件是否能够满足。
    > >
    > > 接下来是算最少步数，这基本就用暴力了，不知道有没有更好的办法。
    > > 首先在所有棋盘上的方格标上0，白色标+1，黑色标-1。白色先走，可以落8个点，如果落点在棋盘内，继续判断。如果这个点已经标了一个负数，那么说明黑色上一步已经可以走到这一点了，此时算一下有多少个这样的点，计算步数，返回，结束。如果没标记（标记为0）就标上2，说明白色走2-1=1步可以到达。如果已经标记了一个正数，说明之前白色就可以到达这一点，所以不再标记（标记的都对应最短步数）。黑色每走一步就减1。这样一直到棋子相遇为止。
    > > 也可以一个棋子不动，只动另一个棋子。不过这样时间空间复杂度似乎变高了。  
    > >
    > > https://www.1point3acres.com/bbs/interview/akunacapital-quant-466472.html
  
* 找是否有共线三点

  * 转化成斜率 + 共点, [max-points-on-a-line](https://leetcode.com/problems/max-points-on-a-line/)
  * 对每个点, 求所有斜率 `(dx/gcd, dy/gcd)`, 如果相同, 表示共线. 考虑垂直和重合
  
* > 给一个 N*N 的数组 （地图），数组元素是 0, 1, -1。 0是冰面，1是可以落脚的雪堆，-1是坑。给定一个你的初始点（在雪堆上），你可以向上下左右任意方向滑行，直到碰到下一个雪堆，或离开边界（获救），或者掉坑里（挂了）。还给定了你的爱犬的初始坐标，也是在一个雪堆上。问能否带着你的狗顺利滑出边界获救。

  * BFS?

* ![1566573168009](D:\OneDrive\Pictures\Typora\1566573168009.png)

  * 模拟?

* 已知一个矩阵，找出满足“该点数值小于周围相邻数值”的点的数值，输出最小的三个

  * 暴力

* 已知一个由positive number组成的array，和一个整数k，输出一个tuple表示subarray的区间，使该subarray的和与k最接近

  * 2 pointer?

* 已知一个‘+’‘-’组成的字符串，每一次要整体flip连续k个字符。问最少需要几次可以全获得‘+’，不能获得的话 输出-1

  * 贪心 最左边0一定要翻转, 滑动窗口维护flip % 2
  * [leetcode-965 minimum-number-of-k-consecutive-bit-flips](https://leetcode.com/articles/minimum-number-of-k-consecutive-bit-flips/)

* palindrome dates

  * ![img](D:\OneDrive\Pictures\Typora\085707q02xl8i8x80d3yee-1566573436713.png)

* 2-36进制转换

* 找出围绕最多的点的个数：一条绸带长度为k，给你一堆点的坐标，问这条带子能围绕住最多多少个点

  * ![1566612774476](D:\OneDrive\Pictures\Typora\1566612774476.png)

  * > 应该先算最小的圈，一个个扩大，直至绳子不能容纳

* 斐波那契数列：给你一个数a，一个值n，问你a能否=不同的n个斐波那契数之和

  * [zhihu](https://www.zhihu.com/question/68360587)
  * dp

* 给一个array（升序排列）和k，k在arrary中，array.size>1。求包含<=k的subarray的median。如果是even，取mean

  * 前缀和+2 pointer?

* 题目说给一个grid，开关灯问题，给first coordinates和turn off lights的coordinates，关灯和（－1，0）／（－1，－1）相连的也关灯。最后看开着的灯数量。

  * > LAMP， 给你矩阵的长宽，起始点，和相对位置，从起始点开始关灯，所有相连位置都要关灯，最后返回亮灯的数目

* 有m个多边形，每个多边形有n条边，每条边可以有k中染色方式，求从多边形中取出两个多边形，染色相同的概率，另如果rotate之后染色相同也算相同，但不能翻折

* 求standard deviation

* 求一个数能否是三个数的乘积

* 将一个矩阵逆时针转九十度

* 将后序表达式转化为中序表达式输出，例如ab+变为a+b, 另外在保证运算正确的情况下括号要最少， 比如 (a+b)+(c+d)括号就是多余的。

  * 栈

* [valid-parentheses](https://leetcode.com/problems/valid-parentheses/)

  * 栈

* 找出三角形内到顶点‍‍‌‌‍‌‌‍‍‌‍‌‌‍‍‍‍‌‍最近的整数点

  * 面积法
  * 叉乘法, 绕三角形一圈 判断同向

* [leetcode-719 find-k-th-smallest pair distance](https://leetcode.com/problems/find-k-th-smallest-pair-distance/)

* ![1566606715107](D:\OneDrive\Pictures\Typora\1566606715107.png)

* 射线与球相交

  * [ref](https://www.jianshu.com/p/1b008ed86627)

* ![1566611011575](D:\OneDrive\Pictures\Typora\1566611011575.png)

  * >   LZ解答：
    >     设期望收益是EX
    >     最后一次，EX = 1/6*（1+2+...+6）=3.5
    >     倒数第二次，扔出4 5 6则放弃下一轮，扔出1 2 3，则选择扔最后一轮，因为最后一轮的期望收益是3.5大于1 2 3
    >     EX = 1/6 * (4+5+6) + 3/6 * 3.5 = 4.25
    >     倒数第三次，扔出5 6则放弃下一轮，扔出1 2 3 4，则选择扔下一轮，因为下一轮的期望收益是4.25大于1 2 3 4
    >     EX = 2/6 *（5+6）+ 4/6 * 4.25 = 14/3
    >
    >    公平的定价应‍‍‌‌‍‌‌‍‍‌‍‌‌‍‍‍‍‌‍该等于玩家的期望收益，所以定价为14/3  

* ![1566611076113](D:\OneDrive\Pictures\Typora\1566611076113.png)

* [最小树形图/有向MST](https://www.cnblogs.com/xzxl/p/7243466.html)

* ![1566612645586](D:\OneDrive\Pictures\Typora\1566612645586.png)

* ![1566612692412](D:\OneDrive\Pictures\Typora\1566612692412.png)

  * 贪心交换?

* Hash Table From Even Stream

  * > 根据一个List of strings重建hashtable，并记录最后一个操作的时间，明显是数据库相关的

* Event Stream From Binary WAL

  * > 给了一个连续byte stream的write ahead log（所有的log都concat在一起），要求用这个重建符合第一题格式的List of strings，并且要根据第一个key sorted。
    >
    > format大致是fixed length时间+fixed length操作类型+fixed length存key length+key length长度的byte（比如key length是10那这个field就读10个byte）+fixed length存value length+value length的value（和key那个field一样）。
    > 挂点：一共有三种log的类型，第三种的byte str‍‍‌‌‍‌‌‍‍‌‍‌‌‍‍‍‍‌‍eam比其他两种要短。我测试的时候发现每次处理完第三种的log去处理下一个log的时候都会超出两个index。一开始认为是sort的问题，发现以后没有调试出问题时间不够没改对。

  * [java](https://www.evernote.com/shard/s705/client/snv?noteGuid=c439dfb0-4759-4056-91da-77cc28efa40f&noteKey=597e8c3f37bcde0d&sn=https%3A%2F%2Fwww.evernote.com%2Fshard%2Fs705%2Fsh%2Fc439dfb0-4759-4056-91da-77cc28efa40f%2F597e8c3f37bcde0d&title=akuna%2Boa%2B2020)

* ![1566613049627](D:\OneDrive\Pictures\Typora\1566613049627.png)

  * 滑动窗口? 

  * [leetcode 713-subarray product less than K](https://leetcode.com/problems/subarray-product-less-than-k/)

  * ```c++
    // 尝试先窗口size优化, 然后二分优化, 挂, 复杂度应该是 log^2n
    // 这题到底是不是contiguous/monotonically increasing subarray?
    long countSubarrays(vector<int> numbers, int k) {
        int N = numbers.size();
        long long p = 1;
        long cnt = 0;
        int times = N;
        if (numbers[0] != 1) {
            times = log(N) / log(numbers[0]);
        } else {
            times = log(N) / log(numbers[1]) + 1;
        }
        vector<long long> pmul(N + 1, 1);
        for (int i = 0; i < N; ++i) {
            pmul[i + 1] = pmul[i] * numbers[i];
            if (numbers[i] <= k)
                ++cnt;
        }
        // 去除N
        if (pmul[N] <= k) {
            return N * (N - 1);
        } else if (times == N) {
            times = N - 1;
        }
        long long l = 0;
        long long r = N - 1;
        for (int i = times; i >= 2; --i) {
            // 不用重置l, l肯定只会增大
            r = N - i;
            // 二分查找i长窗口, upper_bound
            while (l <= r) {
                int mid = (l + r) / 2;
                long long tmp = pmul[mid + i] / pmul[mid];
                if (tmp > k) {
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            }
            cnt += l;
        }
        return cnt;
    }
    ```
    
  * ```c++
    // leetcode解法, O(N), 注意到left最多被移动N次
    int numSubarrayProductLessThanK(vector<int>& nums, int k) {
        int product = 1;
        size_t len = nums.size();
        size_t left = 0;
      int result = len;
        for (size_t right = 0; right < len; ++right)
        {
            product *= nums[right];
            while (product >= k && left <= right) {
                product /= nums[left++];
            }
            result += right - left;
        }
        return result;
    }
    
    ```
  
  * 
  
* ![1566613337835](D:\OneDrive\Pictures\Typora\1566613337835.png)

  * > 可以发现所有数字的质因数个数不会超过7个
    > 一开始先计算1~sqrt(100000)的所有质数
    > 利用质数表对minRotor~maxRotor的所有数字做质因数分解
    > 再利用排容原理计算出每个数字对minRotor~maxRotor的互质数量(ci)
    > 最后答案为sum(ci^(‍‍‌‌‍‌‌‍‍‌‍‌‌‍‍‍‍‌‍rotorCount-1)) minRotor <= i <= maxRotor
    
  * ```c++
    // 容斥法求非互质个数
    int notcoprimes(int m, const vector<int>& factors) {
        vector<int> ps;
        ps.push_back(-1);
        for (int f : factors) {
            int N = ps.size();
            for (int j = 0; j < N; ++j) {
                ps.push_back(ps[j] * f * (-1));
            }
        }
        int sum = 0;
        for (int i = 1; i < ps.size(); ++i) {
            sum += m / ps[i];
        }
        return sum;
    }
    
    int m = 1e9 + 7;
    
    long long modpow(long long base, int exp, int modulus) {
      base %= modulus;
      long long result = 1;
      while (exp > 0) {
        if (exp & 1) result = (result * base) % modulus;
        base = (base * base) % modulus;
        exp >>= 1;
      }
      return result;
    }
    
    int calculateTotalRotorConfiguration(int rotorCount, int minRotorValue, int maxRotorValue) {
        vector<int> primes;
        int sum = 0;
        if (maxRotorValue == 1) return 0;
        // 求素数表
        for (int i = 2; i <= maxRotorValue; ++i) {
            bool div = true;
            for (int j : primes) {
                if (i % j == 0) {
                    div = false;
                    break;
                }
            }
            if (div) {
                primes.push_back(i);
            }
        }
        // 对每个数求互质个数, 则为互质个数^(rc - 1)
        for (int i = minRotorValue; i <= maxRotorValue; ++i) {
            vector<int> factors;
            for (int j : primes) {
                if (i % j == 0)
                    factors.push_back(j);
            }
            int ncp1 = notcoprimes(minRotorValue - 1, factors);
            int ncp2 = notcoprimes(maxRotorValue, factors);
            int cp = maxRotorValue - ncp2 - (minRotorValue - 1 - ncp1);
            sum += modpow(cp, rotorCount - 1, m);
            sum %= m;
        }
        return sum % m;
    }
    ```
    
  * 
  
* ![1566613527344](D:\OneDrive\Pictures\Typora\1566613527344.png)

* ![1566614523446](D:\OneDrive\Pictures\Typora\1566614523446.png)

  * 



## Facebook

* 2019.8 高频题
  * ![1566864770149](D:\OneDrive\Pictures\Typora\1566864770149.png)









## Google

* 2019.8 高频题
  * ![1566864701116](D:\OneDrive\Pictures\Typora\1566864701116.png)



## LinkedIn

* 2019.8 高频题
  * ![1566864797153](D:\OneDrive\Pictures\Typora\1566864797153.png)



## Microsoft

* 2019.8 高频题
  * ![1566864823397](D:\OneDrive\Pictures\Typora\1566864823397.png)



## Uber

* 2019.8 高频题
  * ![1566864844651](D:\OneDrive\Pictures\Typora\1566864844651.png)