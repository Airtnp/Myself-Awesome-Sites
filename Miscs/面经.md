# 面经合集



## 2019 Summer - 2020 Summer Intern

|  Company   |        Open        |        Submitted        |   Status   |                                                              |
| :--------: | :----------------: | :---------------------: | :--------: | ------------------------------------------------------------ |
|   Akuna    | :heavy_check_mark: | :heavy_check_mark: 海投 |  :x: OA挂  |                                                              |
|   Amazon   | :heavy_check_mark: | :heavy_check_mark: 海投 |            |                                                              |
|   Apple    | :heavy_check_mark: | :heavy_check_mark: 海投 |            |                                                              |
|   Airbnb   |                    |                         |            |                                                              |
|   Asana    |                    |                         |            | https://asana.com/jobs/university-recruiting#jobs-listings   |
| Bloomberg  |                    |                         |            |                                                              |
|  Citadel   | :heavy_check_mark: | :heavy_check_mark: 海投 | :x: 简历挂 |                                                              |
| Databricks | :heavy_check_mark: | :heavy_check_mark: 海投 |            |                                                              |
|  Dropbox   | :heavy_check_mark: |                         |            | https://www.dropbox.com/jobs/teams/eng_university_grads#open-positions |
|    Ebay    |                    |                         |            |                                                              |
|  Facebook  | :heavy_check_mark: | :heavy_check_mark: 内推 | :x: 简历挂 |                                                              |
|   Google   |                    |                         |            |                                                              |
|    IBM     | :heavy_check_mark: | :heavy_check_mark: 海投 |            |                                                              |
|   Indeed   |                    |                         |            |                                                              |
|  LinkedIn  |                    |                         |            |                                                              |
|    Lyft    | :heavy_check_mark: | :heavy_check_mark: 内推 |            |                                                              |
| Microsoft  | :heavy_check_mark: | :heavy_check_mark: 海投 |            |                                                              |
|   Nvidia   |                    |                         |            |                                                              |
|   Paypal   | :heavy_check_mark: |                         |            |                                                              |
|  Red Hat   |                    |                         |            |                                                              |
|   Reddit   |                    |                         |            |                                                              |
| Salesforce | :heavy_check_mark: |                         |            | https://salesforce.wd1.myworkdayjobs.com/en-US/External_Career_Site/job/CA---San-Francisco/Summer-2020-Intern---Software-Engineer_JR45627-1 |
|   Slack    |                    |                         |            |                                                              |
|   Twitch   |                    |                         |            |                                                              |
|  Twitter   | :heavy_check_mark: | :heavy_check_mark: 海投 |            |                                                              |
| Two Sigma  | :heavy_check_mark: | :heavy_check_mark: 内推 |            |                                                              |
|    Uber    |                    |                         |            |                                                              |
|   VMWare   |                    |                         |            |                                                              |
|    Yelp    | :heavy_check_mark: | :heavy_check_mark: 内推 |            |                                                              |
|            |                    |                         |            |                                                              |

* [zacklight](https://zacklight.com/internships/)
* [Job Hunting](https://www.notion.so/Job-Hunting-Public-a01874eb0eb54af3a4c0a03447b42534)











## Amazon

* 2019.8 高频题
  
  * ![1566864725814](D:\OneDrive\Pictures\Typora\1566864725814.png)
  
* 二维矩阵横竖都有序，输入一个数返回坐标，没有返回（-1， -1)
  * 二维二分 / 二维双指针, lc原题
  * [leetcode 240 search a 2d matrix](https://leetcode.com/problems/search-a-2d-matrix-ii/)
  
* 输入连通图里的所有边，输出critical connection，即移除该边图不连通‍‍‌‌‍‌‌‍‍‌‍‌‌‍‍‍‍‌‍
  * 求无向连通图的割点
  * ![1567052650935](D:\OneDrive\Pictures\Typora\1567052650935.png)
  * [连通图强连通分量-割点-缩点/Tarjan](https://www.cnblogs.com/stxy-ferryman/p/7779347.html)
  * [求无向连通图的割点](https://www.cnblogs.com/en-heng/p/4002658.html)
  * ![1567054062693](D:\OneDrive\Pictures\Typora\1567054062693.png)
  
* 变形jump game 给两个array 第一个代表位置 第二个代表能跳的步数 可以往后 也可以往前跳 求能不能跳到最后

* 一个array里找最小和第二小的数 要求比较次数不高于O(n)+O(logn)

* [leetcode 572 subtree-of-another-tree](https://leetcode.com/problems/subtree-of-another-tree/)

* > 两个HashMap，第一个Map的key是用户名(String), value是一个String List，里面是video game的名字。第二个Map的key是video game的类型(String), value也是一个String List, 存的是这个类型的所有的video game的名字。要求是返回一个Map，key是用户名，value是一个List，这个List里存用户最喜欢的video game的类型，可以一个可以多个。判断是不是最喜欢的类型是通过看这个用户的video games里哪种类型最多。
  >
  > 比如说类型map是空的，你还是要返回一个跟用户map size一样的map，只不过每个value都是空的list，而不能就返回一个空的map

* 飞机上放音乐还是影片，两个加起来刚好等于一个值而且要包含所有符合的结果里面最长一个电影的。返回一对int
  
  * map O(N)
  
* 飞机来回程利用飞机max range最大的组合。输入是两个二维list，包含index和range
  
  * 暴力
  
* 给定n个文件， 和一个list of file size， 求minimum time to merge file

  * 周赛题, pq

* Remove Obstacle(背景：机器人去除障碍物) 

  * BFS搞定

* Give a computer with total K memory space, and an array of foreground tasks and background tasks the computer need to do. Write an algorithm to find a pair of tasks from each array to maximize the memory usage. Notice the tasks could be done without origin order.

* OOP题
  
  * 设计parking lot
  
* 改正题
  * printPattern even odd类型，跟其他面经一样，for loop missing {}
  * reverse array, len += 1  corrected by len -= 1
  * sort array in decending order, max > arr[j]  corrected by max < arr[j]
  * replace values, i <= len corrected by i < len, the same as j <= len
  * print character pattern, 这道题少大括号或者把 char ch = 'a'移到 for loop 里
  * countOccurrence 返回Value在Array里面出现的次数 while loop里面缺少i++
  * CheckGrade 两个else if里的‘||’改为‘&&’
  * count‍‍‌‌‍‌‌‍‍‌‍‌‌‍‍‍‍‌‍Digits 加一句temp=num; 然后把return里所有的的num改为temp, 这样num就不会被改变了
  
* [OA题](https://drive.google.com/file/d/1pdvVVKoCxtSuerds95iZPAH8k3oEdBr1/)

* [Amazon Online Assessment Questions](https://leetcode.com/discuss/interview-question/344650/Amazon-Online-Assessment-Question)







## Akuna

* 3-card poker

  * ![1566575332614](D:\OneDrive\Pictures\Typora\1566575332614.png)

* >  给你一个国际象棋的棋盘，两个knight的棋子，一黑一白，两个都只能走“L”字形。黑和白两个棋子都由你自己来控制，黑白不断轮流着走，一个一轮。
  >      定义一个函数，input是黑白初始位置坐标，output是黑追上白或者白追上黑的最小可能的步数和他们走过的square的个数。
  
* 视为一个棋子BFS, [马走日](https://blog.csdn.net/jacketinsysu/article/details/52613937)
  
  * > >   首先国际象棋的棋盘是黑白相间的，按题目给出的走法，每走一步必然会变颜色。那么可以看初始条件里两个棋子颜色是否相同，只要计算(x1+y1-x2-y2)%2就可以。如果颜色相同，两个棋子一共需要走偶数步，否则是奇数步。这样就可以判断题目给的条件是否能够满足。
    > >
    > > 接下来是算最少步数，这基本就用暴力了，不知道有没有更好的办法。
    > > 首先在所有棋盘上的方格标上0，白色标+1，黑色标-1。白色先走，可以落8个点，如果落点在棋盘内，继续判断。如果这个点已经标了一个负数，那么说明黑色上一步已经可以走到这一点了，此时算一下有多少个这样的点，计算步数，返回，结束。如果没标记（标记为0）就标上2，说明白色走2-1=1步可以到达。如果已经标记了一个正数，说明之前白色就可以到达这一点，所以不再标记（标记的都对应最短步数）。黑色每走一步就减1。这样一直到棋子相遇为止。
    > > 也可以一个棋子不动，只动另一个棋子。不过这样时间空间复杂度似乎变高了。  
    > >
    > > https://www.1point3acres.com/bbs/interview/akunacapital-quant-466472.html
  
* 找是否有共线三点

  * 转化成斜率 + 共点, [max-points-on-a-line](https://leetcode.com/problems/max-points-on-a-line/)
  * 对每个点, 求所有斜率 `(dx/gcd, dy/gcd)`, 如果相同, 表示共线. 考虑垂直和重合
  
* > 给一个 N*N 的数组 （地图），数组元素是 0, 1, -1。 0是冰面，1是可以落脚的雪堆，-1是坑。给定一个你的初始点（在雪堆上），你可以向上下左右任意方向滑行，直到碰到下一个雪堆，或离开边界（获救），或者掉坑里（挂了）。还给定了你的爱犬的初始坐标，也是在一个雪堆上。问能否带着你的狗顺利滑出边界获救。

  * BFS?

* ![1566573168009](D:\OneDrive\Pictures\Typora\1566573168009.png)

  * 模拟?

* 已知一个矩阵，找出满足“该点数值小于周围相邻数值”的点的数值，输出最小的三个

  * 暴力

* 已知一个由positive number组成的array，和一个整数k，输出一个tuple表示subarray的区间，使该subarray的和与k最接近

  * 2 pointer?

* 已知一个‘+’‘-’组成的字符串，每一次要整体flip连续k个字符。问最少需要几次可以全获得‘+’，不能获得的话 输出-1

  * 贪心 最左边0一定要翻转, 滑动窗口维护flip % 2
  * [leetcode-965 minimum-number-of-k-consecutive-bit-flips](https://leetcode.com/articles/minimum-number-of-k-consecutive-bit-flips/)

* palindrome dates

  * ![img](D:\OneDrive\Pictures\Typora\085707q02xl8i8x80d3yee-1566573436713.png)

* 2-36进制转换

* 找出围绕最多的点的个数：一条绸带长度为k，给你一堆点的坐标，问这条带子能围绕住最多多少个点

  * ![1566612774476](D:\OneDrive\Pictures\Typora\1566612774476.png)

  * > 应该先算最小的圈，一个个扩大，直至绳子不能容纳

* 斐波那契数列：给你一个数a，一个值n，问你a能否=不同的n个斐波那契数之和

  * [zhihu](https://www.zhihu.com/question/68360587)
  * dp

* 给一个array（升序排列）和k，k在arrary中，array.size>1。求包含<=k的subarray的median。如果是even，取mean

  * 前缀和+2 pointer?

* 题目说给一个grid，开关灯问题，给first coordinates和turn off lights的coordinates，关灯和（－1，0）／（－1，－1）相连的也关灯。最后看开着的灯数量。

  * > LAMP， 给你矩阵的长宽，起始点，和相对位置，从起始点开始关灯，所有相连位置都要关灯，最后返回亮灯的数目

* 有m个多边形，每个多边形有n条边，每条边可以有k中染色方式，求从多边形中取出两个多边形，染色相同的概率，另如果rotate之后染色相同也算相同，但不能翻折

* 求standard deviation

* 求一个数能否是三个数的乘积

* 将一个矩阵逆时针转九十度

* 将后序表达式转化为中序表达式输出，例如ab+变为a+b, 另外在保证运算正确的情况下括号要最少， 比如 (a+b)+(c+d)括号就是多余的。

  * 栈

* [valid-parentheses](https://leetcode.com/problems/valid-parentheses/)

  * 栈

* 找出三角形内到顶点‍‍‌‌‍‌‌‍‍‌‍‌‌‍‍‍‍‌‍最近的整数点

  * 面积法
  * 叉乘法, 绕三角形一圈 判断同向

* [leetcode-719 find-k-th-smallest pair distance](https://leetcode.com/problems/find-k-th-smallest-pair-distance/)

* ![1566606715107](D:\OneDrive\Pictures\Typora\1566606715107.png)

* 射线与球相交

  * [ref](https://www.jianshu.com/p/1b008ed86627)

* ![1566611011575](D:\OneDrive\Pictures\Typora\1566611011575.png)

  * >   LZ解答：
    >     设期望收益是EX
    >     最后一次，EX = 1/6*（1+2+...+6）=3.5
    >     倒数第二次，扔出4 5 6则放弃下一轮，扔出1 2 3，则选择扔最后一轮，因为最后一轮的期望收益是3.5大于1 2 3
    >     EX = 1/6 * (4+5+6) + 3/6 * 3.5 = 4.25
    >     倒数第三次，扔出5 6则放弃下一轮，扔出1 2 3 4，则选择扔下一轮，因为下一轮的期望收益是4.25大于1 2 3 4
    >     EX = 2/6 *（5+6）+ 4/6 * 4.25 = 14/3
    >
    >    公平的定价应‍‍‌‌‍‌‌‍‍‌‍‌‌‍‍‍‍‌‍该等于玩家的期望收益，所以定价为14/3  

* ![1566611076113](D:\OneDrive\Pictures\Typora\1566611076113.png)

* [最小树形图/有向MST](https://www.cnblogs.com/xzxl/p/7243466.html)

* ![1566612645586](D:\OneDrive\Pictures\Typora\1566612645586.png)

* ![1566612692412](D:\OneDrive\Pictures\Typora\1566612692412.png)

  * 贪心交换?

* Hash Table From Even Stream

  * > 根据一个List of strings重建hashtable，并记录最后一个操作的时间，明显是数据库相关的

* Event Stream From Binary WAL

  * > 给了一个连续byte stream的write ahead log（所有的log都concat在一起），要求用这个重建符合第一题格式的List of strings，并且要根据第一个key sorted。
    >
    > format大致是fixed length时间+fixed length操作类型+fixed length存key length+key length长度的byte（比如key length是10那这个field就读10个byte）+fixed length存value length+value length的value（和key那个field一样）。
    > 挂点：一共有三种log的类型，第三种的byte str‍‍‌‌‍‌‌‍‍‌‍‌‌‍‍‍‍‌‍eam比其他两种要短。我测试的时候发现每次处理完第三种的log去处理下一个log的时候都会超出两个index。一开始认为是sort的问题，发现以后没有调试出问题时间不够没改对。

  * [java](https://www.evernote.com/shard/s705/client/snv?noteGuid=c439dfb0-4759-4056-91da-77cc28efa40f&noteKey=597e8c3f37bcde0d&sn=https%3A%2F%2Fwww.evernote.com%2Fshard%2Fs705%2Fsh%2Fc439dfb0-4759-4056-91da-77cc28efa40f%2F597e8c3f37bcde0d&title=akuna%2Boa%2B2020)

* ![1566613049627](D:\OneDrive\Pictures\Typora\1566613049627.png)

  * 滑动窗口? 

  * [leetcode 713-subarray product less than K](https://leetcode.com/problems/subarray-product-less-than-k/)

  * ```c++
    // 尝试先窗口size优化, 然后二分优化, 挂, 复杂度应该是 log^2n
    // 这题到底是不是contiguous/monotonically increasing subarray?
    long countSubarrays(vector<int> numbers, int k) {
        int N = numbers.size();
        long long p = 1;
        long cnt = 0;
        int times = N;
        if (numbers[0] != 1) {
            times = log(N) / log(numbers[0]);
        } else {
            times = log(N) / log(numbers[1]) + 1;
        }
        vector<long long> pmul(N + 1, 1);
        for (int i = 0; i < N; ++i) {
            pmul[i + 1] = pmul[i] * numbers[i];
            if (numbers[i] <= k)
                ++cnt;
        }
        // 去除N
        if (pmul[N] <= k) {
            return N * (N - 1);
        } else if (times == N) {
            times = N - 1;
        }
        long long l = 0;
        long long r = N - 1;
        for (int i = times; i >= 2; --i) {
            // 不用重置l, l肯定只会增大
            r = N - i;
            // 二分查找i长窗口, upper_bound
            while (l <= r) {
                int mid = (l + r) / 2;
                long long tmp = pmul[mid + i] / pmul[mid];
                if (tmp > k) {
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            }
            cnt += l;
        }
        return cnt;
    }
    ```
    
  * ```c++
    // leetcode解法, O(N), 注意到left最多被移动N次
    int numSubarrayProductLessThanK(vector<int>& nums, int k) {
        int product = 1;
        size_t len = nums.size();
        size_t left = 0;
      int result = len;
        for (size_t right = 0; right < len; ++right)
        {
            product *= nums[right];
            while (product >= k && left <= right) {
                product /= nums[left++];
            }
            result += right - left;
        }
        return result;
    }
    
    ```
  
  * 
  
* ![1566613337835](D:\OneDrive\Pictures\Typora\1566613337835.png)

  * > 可以发现所有数字的质因数个数不会超过7个
    > 一开始先计算1~sqrt(100000)的所有质数
    > 利用质数表对minRotor~maxRotor的所有数字做质因数分解
    > 再利用排容原理计算出每个数字对minRotor~maxRotor的互质数量(ci)
    > 最后答案为sum(ci^(‍‍‌‌‍‌‌‍‍‌‍‌‌‍‍‍‍‌‍rotorCount-1)) minRotor <= i <= maxRotor
    
  * ```c++
    // 容斥法求非互质个数
    int notcoprimes(int m, const vector<int>& factors) {
        vector<int> ps;
        ps.push_back(-1);
        for (int f : factors) {
            int N = ps.size();
            for (int j = 0; j < N; ++j) {
                ps.push_back(ps[j] * f * (-1));
            }
        }
        int sum = 0;
        for (int i = 1; i < ps.size(); ++i) {
            sum += m / ps[i];
        }
        return sum;
    }
    
    int m = 1e9 + 7;
    
    long long modpow(long long base, int exp, int modulus) {
      base %= modulus;
      long long result = 1;
      while (exp > 0) {
        if (exp & 1) result = (result * base) % modulus;
        base = (base * base) % modulus;
        exp >>= 1;
      }
      return result;
    }
    
    int calculateTotalRotorConfiguration(int rotorCount, int minRotorValue, int maxRotorValue) {
        vector<int> primes;
        int sum = 0;
        if (maxRotorValue == 1) return 0;
        // 求素数表
        for (int i = 2; i <= maxRotorValue; ++i) {
            bool div = true;
            for (int j : primes) {
                if (i % j == 0) {
                    div = false;
                    break;
                }
            }
            if (div) {
                primes.push_back(i);
            }
        }
        // 对每个数求互质个数, 则为互质个数^(rc - 1)
        for (int i = minRotorValue; i <= maxRotorValue; ++i) {
            vector<int> factors;
            for (int j : primes) {
                if (i % j == 0)
                    factors.push_back(j);
            }
            int ncp1 = notcoprimes(minRotorValue - 1, factors);
            int ncp2 = notcoprimes(maxRotorValue, factors);
            int cp = maxRotorValue - ncp2 - (minRotorValue - 1 - ncp1);
            sum += modpow(cp, rotorCount - 1, m);
            sum %= m;
        }
        return sum % m;
    }
    ```
    
  * 
  
* ![1566613527344](D:\OneDrive\Pictures\Typora\1566613527344.png)

* ![1566614523446](D:\OneDrive\Pictures\Typora\1566614523446.png)

  * 



## Facebook

* 2019.8 高频题
  * ![1566864770149](D:\OneDrive\Pictures\Typora\1566864770149.png)

* 二叉搜索树范围内的和

  * [leetcode 938 range-sum-of-bst](https://leetcode.com/problems/range-sum-of-bst/)

    * 因为是BST, 直接判断左子树右子树

    * ```c++
      class Solution {
      public:
          int rangeSumBST(TreeNode* root, int L, int R) {
              if (!root)
                  return 0;
              if (root->val < L)
                  return rangeSumBST(root->right, L, R);
              if (root->val > R)
                  return rangeSumBST(root->left, L, R);
              return rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R) + root->val;
          }
      };
      ```

    * 或者DFS序LCA

  * 







## Google

* 2019.8 高频题
  
* ![1566864701116](D:\OneDrive\Pictures\Typora\1566864701116.png)
  
* > Strictly Smaller：给两个strings A and B，返回一个int数组。数组里面的每个数值记录了针对每个B里的substring，A里有多少个partition是strictly smaller than B的。比如说A = "qaaazx aab ba", B = "aaa bb"，则返回[2,1]，因为A里面的"aab", "ba" 的a的出现频率都是小于B的"aaa"的，所以第一位是1；同理，"aab"和"ba" 都是strictly smaller than "bb"的，所以第二位填2. str‍‍‌‌‍‌‌‍‍‌‍‌‌‍‍‍‍‌‍ictly smaller指的是拿每个string里的最小字符(lexicographical order)出现次数做对比.

  * 题目准确率存疑

* > Largest Continguous Subarray：给一个数组A和一个长度K，返回最大的长度为K的连续数组，其中最大的定义是比如A = [3,6,2,9,7,6], K = 5, 一共会出现两个subarray a=[3,6,2,9,7], b=[6,2,9,7,6]，第二个数组大于第一个数组，因为他们在index为0的时候就不相等且a[0] < b[0]。要看的就是俩俩数组对比下来他们第一次不相等的时候是谁在那个index上的value比较大

  * 

* > 有一个显示屏，给定长度和宽度。同时有一行只含字母的字符串，每个字符的大小与其对应的font-size有关，font-size范围从0到100。
  > Question: font-size最大取多少，这个显示屏可以完全展示整个字符串。
  > API：GetWidth(char a, int font_size); GetHeight(int font_size);
  > NOTE：对于相同font-size的字母，高度一样宽度不同。一个字母在一行放不下后，必须放到第二行，不能半个在a行，半个在a+1行。

  * 

* > 有一个matrix，其中只有1和0，1为可通过，0为不可通过。
  > Question: 找出最短的一条路径，从matrix的第一行能到最后一行，并输出路径。
  > NOTE: 无路可走，输出空的vector。多条路最短，输出任意一条。
  > Follow Up: matrix 变为n和0，n为可通过的cost，0为不可通过，问题一样。

  * Dijkstra

* 给一个binary tree, 其中有节点会乱指, 将乱指的节点指向空, 有不同种可能时, 返回深度最小的binary tree

* merge intervals

  * [leetcode 56 merge-intervals](https://leetcode.com/problems/merge-intervals/)

* 离原点第K近的点

* 二叉树和最大的层数

* 用卡牌组成给定的伤害

* 椅子数目（meeting room2）

* 奇偶跳

* 减法减string

* 打字string的总距离



## LinkedIn

* 2019.8 高频题
  * ![1566864797153](D:\OneDrive\Pictures\Typora\1566864797153.png)



## Microsoft

* 2019.8 高频题
  * ![1566864823397](D:\OneDrive\Pictures\Typora\1566864823397.png)



## Twitter

* restock 仓库问题, 有一个list,每个数字对应供应商每个 item 能提供的货物量, 还有一个 target 是你要采购的目标, 进货只能从list 的第 0 个开始连续买, 买到达到 target 的量就停止, 如果全买完都没到达 target 也只能停止, 返回你所购买的货物的量和 target 差的绝对值
  * 前缀和, 二分
* weird faculty, 有n 个问题和对应的答对答错情况, 答对+1 分,答错-1 分, 有两个人你和你朋友, 你可以选择回答 top k 个问题, 你朋友答剩下的 n-k 个问题, 求你可选择的最小 k, 使你的分数大于你朋友的分数
* 给两个字符串 a,b,‍‍‌‌‍‌‌‍‍‌‍‌‌‍‍‍‍‌‍ 计算一个字符串a经过多少次 modification 就可以变成字符串 b 的 anagram
  * 计数, 贪心?
* 给一系列喷泉,问最少用几个就能覆盖所有范围
* [leetcode 496 next greater element i](https://leetcode.com/problems/next-greater-element-i/)
  * 单调栈维护next greater存到unordered_map中
* partition array，题目老长了，其实就是能整分 并且 出现次数不大于k
* 调整`vector<int>`, 使得没有重复数字，并且sum最小
* 返回vector里能组成的pair数，使其abs差值==k
* Final discounted price，看了半天就是first next‍‍‌‌‍‌‌‍‍‌‍‌‌‍‍‍‍‌‍ less or equal
  * 单调栈





## Uber

* 2019.8 高频题
  * ![1566864844651](D:\OneDrive\Pictures\Typora\1566864844651.png)



## VMWare

* 找第K大数
* m*n矩阵，激光从左上角走到右下角的所有路径
  * 如果有障碍物的所有路径
* 树的左右‍‍‌‌‍‌‌‍‍‌‍‌‌‍‍‍‍‌‍最长距离