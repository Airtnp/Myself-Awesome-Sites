# Power Struggles: Revisiting the RISC vs. CISC Debate on Contemporary ARM and x86 Architecture

**Emily Blem, Jaikrishnan Menon, Karthikeyan Sankaralingam**

---



## Introduction

* RISC vs. CISC wars: 1980s
  * major concern: chip area, processor design complexity
  * major user: desktop, server
* today condition
  * energy, power as the primary design
  * tablets, smartphones running ARM (RISC)
  * desktops, laptops running x86 (CISC)
* whether ISA plays an intrinsic role in performance / energy efficiency?
* conclusion: ARM, x86 processors are simply engineering design points optimized for different levels of performance
  * nothing fundamentally more energy efficient
  * RISC vs. CISC ISA irrelevant
* previous study
  * CISC limits the performance, requires aggressive microarchitecture optimizations for CISC to bridge the performance gap (x86 vs. Alpha)
  * similar with aggressive microarchitecture techniques for ILP (x86 vs. POWER)
  * macro-op cracking?
* ARM vs. x86 on power, energy, performance
* Challenges
  * separating out the multiple implementation factors that are orthogonal to the ISA from the influenced / driven by ISA
  * ISA dependent factors: chip process technology node, device optimization (high-perf, low-power, low-standby power transisor), memory bandwidth, I/O device effects, OS, compiler, workloads
    * [[Q: how do these factors be ISA-dependent?]]
    * exacerbated considering energy measurements/analysis
      * chips implementing an ISA sit on boards
      * separating out chip energy from board energy presents additional challenges
    * some microarchitecture features may be required by the ISA, while others may be dictated by performance & application domain targets (ISA-independent)
* Consider multiple chips for each ISA with similar microarchitecture
  * established technology models to separate technology impact
  * same OS, compiler front-end
    * [[Q: but compile to different ISA makes differences hmmm...]]
  * construct workload not rely on OS
  * ![image-20200107201513197](D:\OneDrive\Pictures\Typora\image-20200107201513197.png)
* whether, if so, how the ISA impacts performance & power
* Key Findings
  * large performance gaps exist across implementations, althrough average cycle count gap $\leq$ 2.5x
  * instruction count & mix are ISA-independent to first order
  * performance differences are generated by ISA-independent microarchitecture differences
  * energy consumption is again ISA-independent
  * ISA different $\to$ implementation implications, but not fundamentally efficiency different
  * ARM & x86 impl. are simply design points optimized for different perf. levels
* Implications
  * microarchitectural effects dominate performance + power + energy



## Framing Key Impacts of the ISA

* ISA features: format, operations, operands
* ![image-20200107211412642](D:\OneDrive\Pictures\Typora\image-20200107211412642.png)
* ISAs are evolving:
  * more semantic information expressed (SSE, larger address space)
  * better security (ARM TrustZone)
  * better virtualization



## Infrastructure



### Implementation Rationale & Challenges

* challenges
  * difference in technology (technology node, freq., high perf./low power transistor)
  * ISA-independent microarchitecture (L2 cache, memory controller, memory size)
  * system effects (OS, compiler)
* commerically relevant (not vastly different time-frames)
* ![image-20200107213605471](D:\OneDrive\Pictures\Typora\image-20200107213605471.png)
* ![image-20200107213622231](D:\OneDrive\Pictures\Typora\image-20200107213622231.png)
  * reasonably equal footing
  * similar microarchitectural features (issue-width, caches, main-memory, similar technology nodes)
  * usable software platform of OS, cross-comilation, driver
  * [[Q: really?]]
* a key challenge: really workload on relatively small memory (512MB) on the Cortex-A8 Beagleboard
  * SPEC2006 workloads, since execution times may be dominated by swapping & OS overheads



### Implementation Platform

* Hardware platform: 2 chip impl. each for ARM & x86
  * keep non-processor features as similar as possible
* Operating system: same stable Linux 2.6 LTS kernel with some minor board-specific patches (for perf. counter subsystem)
  * `perf` program samping for fraction of time spent in the kernel
  * less than 5% for all but `GemsFDTD` & `perfbench` (< 10%)
  * fraction of time spent in OS virtually identical across platforms spanning ISAs
  * keep OS effects as similar as possible
* Compiler: validated `gcc` 4.4 based cross-compilation configuration
  * same front-end for all binaries
  * `O3` enabled ([[Q: no `march=native`?, no flags?]])
  * 32-bit (since 64-bit ARM under dev.)
  * disable ARM THUMB instructions for more RISC-like ISA
  * machine-specific optim. impacts < 5% for half SPEC, $\pm$20% on remaining [[Q: how to measure machine-specific optim. impacts?]]
  * although allow auto-vectorization, few SIMD instruction generated for either architecture
  * floating point on SSE (x86) & NEON (ARM) units
  * hold compiler effects constant



## Applications

* ![image-20200107215523589](D:\OneDrive\Pictures\Typora\image-20200107215523589.png)
* single-threaded workloads
* Mobile client: several accelerators, careful analysis
  * BBench: web-page rendering benchmark comprising 11 of the most sites on the Internet
  * cross platform WebKit to avoid browser differences
* Desktop: SPECCPU2006
  * large memory footprint on Cortex-A8?
  * report results using the test inputs instread
    * 10 of 12 INT, 10 of 17 FP
    * [[Q: can test inputs represent the actual testing?]]
* Server: CloudSuite (data analytics, data streaming, media streaming, software testing, web search, web serving)
  * for entire system & server cluster
  * pick impl. with small memory footprints, single-node behavior
  * Nutch $\to$ CLucene
  * Apache $\to$ lighttpd



### Tools

* Native execution time & microarchtectural events: wall-clock time, perf-counter-based clock-cycle
  * perf. counter to understand microarchitecture influences on the execution time
  * branch mis-prediction rate
  * L1 data cache miss rate
  * L1 instruction miss rate
* Power: Wattsup meter
  * consistent average power, subtract the board power alone
  * power in the supply line of processor? not possible for SoC-based ARM boards
  * validate using i7 exposed energy counters $\to$ 4% - 17% kess than reported
  * optimistic results for power
* Technology scaling & projections: i7 32nm, A8 65nm
  * 2007 ITRS table to normalize to 45nm
    * [[Q: Is this table accurate? Why performance can be scaled?]]
  * device type not counted (LOP, HP, LSTP)
  * A8's power scaled by 0.8X, i7's power by 1.3X
  * scale freq. to 1GHZ, accounting for DVFS (dynamic voltage & freq. scaling) impact on voltage
    * mappings disclosed for Intel SCC
  * 20% of the i7's power is static, not scale with freq. 
  * all other cores are assumed to have negligible static power
  * A8's power scaled by 1.2X, Atom's power by 0.8X, i7's power by 0.6X
  * scaling introduces some errors, by feel it is reasonable
    * [[Q: hmmm. hmmm..]]
* Emulated instruction mix measurement
  * DynamoRIO for x86
  * gem5 simulator's functional emulator to derive instruction mixes for ARM ISA
  * MICA tool to find available ILP



### Limitations/Concerns

* limitations: core diversity, domain, tool, scaling effects
* believe first order effects are perf./power/energy

* ![image-20200107230817405](D:\OneDrive\Pictures\Typora\image-20200107230817405.png)



## Methodology

* ![image-20200107231115838](D:\OneDrive\Pictures\Typora\image-20200107231115838.png)
* approach: understand all perf./power differenes, use the measured metrics to quantify the root causes of differences. Whether or not ISA differences contributes?



### Performance Analysis Flow

* Present execution time for each benchmark
* Normalize frequency's impact using cycle counts
* To understand diff. in cycle count & influence of ISA, present dynamic inst. count measures
  * measured in both macro-ops & micro-ops
* Use instruction mix, code binary size, average dynamic inst. length to understand ISA's influence
* To understand perf. diff. not attributable to ISA, look at detailed microarchitecture events
* Attribute perf. gaps to frequency, ISA, or ISA-independent microarchitecture features.
  * Qualitatively reason whether ISA counts.



### Power & Energy Analysis Flow

* Present per benchmark raw power measurements
* To factor our the impact of technology, present tech-independent power by scaling all processors to 45nm, normalizing freq. to 1GHz
* To understand the interplay between power & perf., examine raw energy
* Qualitatively reason about the ISA influence on microarchitecture in terms of energy



### Trade-off Analysis Flow

* Combine the perf. & power measures, compare the processors impl. using Pareto-frontiers
* Compare measured & synthetic processors impl. using Energy-Performance Pareto-frontiers



## Measured Data Analysis & Findings

* A8 & Atom (dual issue in-order)
* A9 & i7 (OoO)
* present data, average in-order, OoO ratios, main findings
  * some benchmarks are outliers? average included



### Performance Analysis

* Execution Time Comparsion
  * Data: execution time normalized to i7
    * ![image-20200108202319339](D:\OneDrive\Pictures\Typora\image-20200108202319339.png)
  * Outliers
    * A8 on WebKit & `lighttpd`
    * 5 SPEC FP
  * Findings
    * large perf. gaps are platform/benchmark dependent
  * Key Finding
    * large perf. gaps as expected, since freq. ranges from 600MHz to 3.4GHz
* Cycle-Count Comparison
  * Data
    * ![image-20200108202645428](D:\OneDrive\Pictures\Typora\image-20200108202645428.png)
    * ![image-20200108202713963](D:\OneDrive\Pictures\Typora\image-20200108202713963.png)
  * Findings
    * per suite cycle count gaps between OoO/in-order impl. are less than 2.5X/1.5X (no outliers)
  * Key Finding
    * perf. gaps as cycle counts, less than 2.5X
* Instruction Count Comparison
  * Data
    * ![image-20200108202906412](D:\OneDrive\Pictures\Typora\image-20200108202906412.png)
  * Outliers
    * A8 on `wkperf` & `lighttpd`
    * x86 for `CLucence` (pathological case of x76 code generation)
    * ARM on `cactusADM` , micro-ops 2.7X macro-ops (not seen for other bench.)
  * Findings
    * inst. count similar across ISAs $\Rightarrow$ `gcc` picks RISC-like inst. from x86 ISA ([[Q: this is questionable]])
    * ARM outliers in SPEC FP due to transcendental FP ops supported only by x86
    * x86 micro/macro < 1.3X $\Rightarrow$ `gcc` picks RISC-like insts. ([[Q: same question]])
  * Key Finding
    * inst. & cycle count imply CPI is less on x86 impl.
    * x86 ISA overheads, if any, overcomed by microarchitecture
* Instruction Format & Mix
  * Data for binary size & inst. length:
    * ![image-20200108203332181](D:\OneDrive\Pictures\Typora\image-20200108203332181.png)
  * Outliers
    * `CLucene` binary for x86
  * Finding
    * Average ARM & x86 binary size similar for SPEC INT/FP, Mobile
    * execute x86 inst. on average 25% shorter than ARM
    * x86 FP bench. have inst. with longer encodings
  * Data for instruction mix:
    * ![image-20200108203622035](D:\OneDrive\Pictures\Typora\image-20200108203622035.png)
    * ![image-20200108203639289](D:\OneDrive\Pictures\Typora\image-20200108203639289.png)
  * Findings
    * fractions of load/store similar across ISA
    * large inst. count for ARM due to absence of FP inst. (`fsincon`, `fyl2xpl`)
  * Key Finding
    * ISA effects are indistinguishable between x86 & ARM impl.
* Microarchitecture
  * Data for cycle count & microarchitecture:
    * ![image-20200108203928794](D:\OneDrive\Pictures\Typora\image-20200108203928794.png)
  * Findings
    * A9 & i7's different issue width explan the 2x perf. diff. assuming sufficient ILP/inst. window/well balanced pipeline. (MICA shows all bench. have limit ILP > 4)
      * [[N: A9 pipeline show its quad-issue?]]
    * A9 within 2X cycle count of i7, explained by diff. in issue width
  * Data for branch misprediction & L1 data & inst. cache misses
    * ![image-20200108204747275](D:\OneDrive\Pictures\Typora\image-20200108204747275.png)
  * Findings
    * large microarchitectural event count diff. due to design choices (A9's BTB 512 entires vs. i7 16K entires)
    * per bench, can attribute largest gaps in i7 to A9 to specific microaritectural events
      * ![image-20200108205025240](D:\OneDrive\Pictures\Typora\image-20200108205025240.png)
      * [[N: MPKI: missed pred.per 1000 inst.]]
  * Key Finding
    * microarchitecture has significant impact on perf.
    * similar inst. count for x86 & ARM, but x86 branch predictor is better with large cache
* ISA influence on microarchitecture
  * Key Finding
    * only case where ISA forces: ROB size, physical rename file (physical register file) size, scheduler (issue selector?) size
      * [[Q: why scheduler size is impacted by ISA?]]



### Power & Energy Analysis

* normalize to A8 as it uses the least power
* Average Power
  * Data (without normalize):
    * ![image-20200108210932519](D:\OneDrive\Pictures\Typora\image-20200108210932519.png)
    * ![image-20200108210942616](D:\OneDrive\Pictures\Typora\image-20200108210942616.png)
  * Key Finding
    * overall x86 impl. consume significant more power than ARM impl.
* Average Technology Independent Power
  * Data (with node scaling, A8 65nm $\to$ 45nm, i7 22nm $\to$ 45nm):
    * ![image-20200108211122975](D:\OneDrive\Pictures\Typora\image-20200108211122975.png)
  * Finding
    * with freq. & tech. scaling, ISA appears irrelevant for power optim. cores
    * i7 is perf., not power optimized
  * Key Finding
    * choice of power/perf. optimized core designs implacts core power use more than ISA
* Average Energy
  * Data (energy = power x time):
    * ![image-20200108211616335](D:\OneDrive\Pictures\Typora\image-20200108211616335.png)
  * Findings
    * Atom < A8, i7 slightly < A9 due to faster execution time
    * for high cache miss rate & poorly utilized core, fixed energy costs from structured provided for high-perf. makes i7 energy 2X/3X worse than A9
  * Key Finding
    * energy use is primiarly impacted by design choice
    * ISA impact on energy is insignificant
* ISA impact on microarchitecture
  * Findings
    * energy impact of ISA: micro-ops translation & additional macro-ops cache
      * but \# of micro-ops is not significantly higher
    * power hungry structures (L2 cache, highly associative TLB, aggressive prefetcher, large bp) dictated primarly by perf. level & application domain. not necessitated by x86 ISA features



### Trade-off Analysis

* Power-Performance Trade-offs
  * Data (cubic curve):
    * ![image-20200108212025613](D:\OneDrive\Pictures\Typora\image-20200108212025613.png)
  * Findings
    * A9 provdes 3.5X better pref. using 1.8X power of A8
    * i7 provides 6.2X better perf. using 10.9X power of Atom
    * i7's microarchitecture has high energy cost when perf. is low.
  * Key Finding
    * high perf. processors require more power than lower-perf. processors
* Energy-Performance Trade-offs
  * Data (quadratic curve):
    * ![image-20200108215301169](D:\OneDrive\Pictures\Typora\image-20200108215301169.png)
  * Findings
    * power-only/perf-only optimized cores have high energy overheads regardless of ISA (A8 & i7)
    * balancing power & perf. leads to energy-efficient cores regardless of ISA (A9 & Atom)
    * DVFS & microarchitectural techniques can provide energy-efficiency to perf. optimized cores
    * consider energy-delay metric (ED), cores designed balancing show the best ED
    * high-perf. cores seem best suited if weighting the importance of perf. only slightly more than power
  * Key Finding
    * It's the microarchitecture & design methodologies really matter



## Conclusion

* ![image-20200108215835938](D:\OneDrive\Pictures\Typora\image-20200108215835938.png)
* ![image-20200108215904810](D:\OneDrive\Pictures\Typora\image-20200108215904810.png)
* ![image-20200108220005003](D:\OneDrive\Pictures\Typora\image-20200108220005003.png)
* 











##  Summary

- This paper wants to answer the old question: whether ISA plays an intrinsic role in performance or energy efficiency? Early studies on this topic argue that RISC and CISC ISAs had fundamental differences and the performance gaps required aggressive microarchitecture optimizations for CISC to partially bridge the gap. However, with evolving ISA and modern microarchitecture design, the authors argue that there is no fundamental difference between RISC or CISC ISAs on performance and energy efficiency.

## Methods & Results

- The authors investigated a wide range of platforms and ultimately picked 4 platforms: Beagle-board (Cortex-A8), Pandaboard (Cortex-A9), Atom board and Intel i7 Sandybridge. These platforms don't share exactly the same parameters except for ISA, but the choice provides a reasonably equal footing for comparing x86 and ARM. The rest factors, including hardware platform, OS (Linux 2.6 LTS), compiler (gcc) are kept nearly the same. The benchmarks are selected from three fields: mobile (WebKit), desktop (SPEC) and server (CloudSuite) with modifications for portable tests. The authors measured metrics by `perf`, PMU events, Wattsup meter and normalized the results to eliminate differences rising from technology node and DVFS. Three analysis flow (performance, power & energy, trade-off) are performed, through raw data, normalized data, microarchitecture events to qualitative reasoning about ISA influence. The authors collect wall-clock execution time, cycle count, instruction count, binary size, average instruction length, branch miss rate, L1D cache misses, instruction cache misses, raw processor power and energy consumption among all four platforms on given applications. The results show that ISAs don't have much impact on performance (cycle count, instruction count), microarchitecture and energy. However, the microarchitecture and design choices (power-centric vs. performance-centric) deeply affects the behavior of different platforms. There are some outliers in the experiment, however, all of them can be attributed to ISA-independent microarchitecture features, like lacking FP instructions, bad code generation.

## Personal Opinions

- I think this paper was really solid and required a large amount of work. The authors tried their best to provide an equal footing among different platforms, which I believed it's impossible without a strong understanding of computer architecture. The good things are they collected solid data, provided a detailed analysis on every test, and reasoned qualitatively on the results. Especially, they overcame the difficulties on technology node, DVFS, measurement and many others. I really admire the methodology and the hard work they did. Some deficiencies about the survey I think out are, the second-order effects excluded from consideration are not qualitatively measured. Meanwhile, I can't understand the mechanism of normalization between different technology nodes and DVFS, so I'm suspect on the scaling correctness. The most critical concern I have is the microarchitecture techniques and compiler efficiency. The authors simply considered two OoO processors and two in-order processors as the same microarchitecture. However, could it be Intel employed some advanced techniques within its processors and we lead to a conclusion same as the early ISA studies? Also, the authors measured that the impact of machine-specific optimizations is less than 5% (which I don't understand) and stated that `gcc` would pick some RISC-like instructions in x86 for targeting binary. I think the authors need to consolidate their statements. Would the gcc compiler toolchain have better optimization for x86 since it targets more users and more developers just devoted to it? In conclusion, I think for observable (compiler + OS + application + hardware) performance and power, ISAs make no difference, but for hardware only performance, it still remains a mystery.
- PS: this paper reminds me of an article [RISC is fundamentally unscalable](https://erikmcclure.com/blog/risc-is-fundamentally-unscalable/)
- [RISC-V critiques](https://gist.github.com/erincandescent/8a10eeeea1918ee4f9d9982f7618ef68)
  - [HN comments](http://hn.premii.com/#/comments/24958423)

