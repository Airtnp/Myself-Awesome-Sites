# Cpp Quiz

## aggr-init vs. delete function
* [dis](https://stackoverflow.com/q/33988297/8563711)
```c++
struct Foo
{
Foo(const Foo &) = delete;
};
int main() { Foo bar{}, b2{ Foo{} }; } // OK

struct Foo
{
Foo(const Foo &) = delete;
};
int main() { Foo bar{}, b2{ Foo{} }; } // Error

struct Foo
{
explicit Foo(const Foo &) = delete;
};
int main() { Foo bar{}, b2{ Foo{} }; } // Error

struct Foo
{
Foo() = delete;
};
int main() { Foo bar{}; } // OK

struct Foo
{
Foo() = delete;
Foo(int);
};
int main() { Foo bar{}; } // Error

struct Foo
{
private:
Foo();
};
int main() { Foo bar{}; } // Error

```

## return initializer_list?
```c++
static int a = 1;
static int b = 2;

initializer_list<int> foo() {
    return {a, b} // copy first, return (assign by pointer)
}

int main() {
    auto p = foo(); // Error: dangling pointer
}

```

## void()
```c++
template <typename T>
T foo1() {
    return T();
}

template <typename T>
T foo2() {
    return T{};
}

template <typename T>
void foo3() {
    auto p = new T{};
    delete p;
}

void bar() {
    return void(); // OK
}

void baz() {
    return void{}; // Error
}
```
* std::invoke with return void

## Unicode support
```c++
char* \U0001f431 = "cat" // OK
char* ðŸ˜º = "cat" // Error in GCC

int abc = 1;
int ab\u200c = 1;
int a\u200bc = 1;
int abc\u200 = 1;
```

## Lambda capture forwarding and universal reference
* [dis](https://stackoverflow.com/questions/46118564/alternative-for-stdbind-in-modern-c)
```c++
template<class T>
template<typename F, typename ...Args>
T Container<T>::addTask(F&& func, Args&&... args)
{
    container.emplace_back( [func = std::forward<F>(func),
                             args = std::make_tuple(std::forward<ARGS>(args)...)                                 ] 
                             ()  mutable // make mutable if you want to move the args in to func
                             {
                                 return std::apply(func, std::move(args));
                             });

    //.....
}
```

## Delete element in Cpp
* vector erase-remove
* remove_if
* [dis](https://stackoverflow.com/questions/38468844/erasing-elements-from-unordered-map-in-a-loop)
```c++
std::unordered_map<...> m;
auto it = m.begin();
while (it != m.end())
{
    if (pred(*it))
        it = m.erase(it);
    else
        ++it;
} // UB before Cpp14

std::unordered_map<...> mymap;
std::vector<decltype(mymap)::key_type> vec;
for (auto&& i : mymap)
    if (/*compare i*/)
        vec.emplace_back(i.first);
for (auto&& key : vec)
    mymap.erase(key);
```

## Nested using 
```c++
template <typename T>
template <typename U>
using P = std::is_same<T, U>; // Usable in gcc, failed in clang
                              // ill-formed

```

## vector.resize()
* [discuss](https://www.zhihu.com/question/65997834/answer/237364710)

## tie and tie
```c++
int a = 1, b = 2, c = 3;
std::tie(a, b, c) = {c, a, b};
cout << a << ' ' << b; // 3 3 well-defined?
```

## integer conversion
```c++
sizeof('a' + ' ') == sizeof(int) // true (C even char/bool literal = int)
-1L < 1U // long > int -> convert to long 1 | long == int -> convert to unsigned long 0
```

## default function argument
* ref: SuperNaiveCppLib/notes/CppCon2017/Notes

## launder
* make compiler remove const assumption
```c++
struct X {
    const int n;
    const double d;
};
X* p = new X{7, 8.8};
new (p) X{42, 9.9}; // place new value into p
int b = std::launder(p)->n; // OK, b is 42
int c = p->n; // undefined behavior!
double d = p->d; // undefined behavior!
```

## copy=elision
```c++
struct foo {
    foo() = default;
    foo(cosnt foo&) = delete;
};

int main() {
    auto x = foo(); // prev-17: error! | 17: prvalue copy elision
}
```

## copy-and-swap without customize swap
```c++
class A {
    A(const A&) = default;
    A& operator(const A& rhs) {
        delete();
        A temp(rhs);
        std::swap(*this, temp); // infinite loop! will call copy ctor
        return *this;
    }  
};

```

## string literal is anonymous lvalue
```c++
const_cast<char*>("WTF")[0] = 'd'; // OK, though segmentation fault
true = false; // Failed, 1 is prvalue. <del>Python 2 will allow this</del>
```

## func-macro and identifier
```c++
class A {};

#define A(x) _

int main() {
    A a{}; // OK
    A(a{}); // Error
}
```