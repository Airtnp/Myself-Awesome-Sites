# Cpp Quiz

## aggr-init vs. delete function
* [dis](https://stackoverflow.com/q/33988297/8563711)
```c++
struct Foo
{
Foo(const Foo &) = delete;
};
int main() { Foo bar{}, b2{ Foo{} }; } // OK

struct Foo
{
Foo(const Foo &) = delete;
};
int main() { Foo bar{}, b2{ Foo{} }; } // Error

struct Foo
{
explicit Foo(const Foo &) = delete;
};
int main() { Foo bar{}, b2{ Foo{} }; } // Error

struct Foo
{
Foo() = delete;
};
int main() { Foo bar{}; } // OK

struct Foo
{
Foo() = delete;
Foo(int);
};
int main() { Foo bar{}; } // Error

struct Foo
{
private:
Foo();
};
int main() { Foo bar{}; } // Error

```

## return initializer_list?
```c++
static int a = 1;
static int b = 2;

initializer_list<int> foo() {
    return {a, b} // copy first, return (assign by pointer)
}

int main() {
    auto p = foo(); // Error: dangling pointer
}

```

## void()
```c++
template <typename T>
T foo1() {
    return T();
}

template <typename T>
T foo2() {
    return T{};
}

template <typename T>
void foo3() {
    auto p = new T{};
    delete p;
}

void bar() {
    return void(); // OK
}

void baz() {
    return void{}; // Error
}
```
* std::invoke with return void

## Unicode support
```c++
char* \U0001f431 = "cat" // OK
char* ðŸ˜º = "cat" // Error in GCC

int abc = 1;
int ab\u200c = 1;
int a\u200bc = 1;
int abc\u200 = 1;
```

## Lambda capture forwarding and universal reference
* [dis](https://stackoverflow.com/questions/46118564/alternative-for-stdbind-in-modern-c)
```c++
template<class T>
template<typename F, typename ...Args>
T Container<T>::addTask(F&& func, Args&&... args)
{
    container.emplace_back( [func = std::forward<F>(func),
                             args = std::make_tuple(std::forward<ARGS>(args)...)                                 ] 
                             ()  mutable // make mutable if you want to move the args in to func
                             {
                                 return std::apply(func, std::move(args));
                             });

    //.....
}
```

## Delete element in Cpp
* vector erase-remove
* remove_if
* [dis](https://stackoverflow.com/questions/38468844/erasing-elements-from-unordered-map-in-a-loop)
```c++
std::unordered_map<...> m;
auto it = m.begin();
while (it != m.end())
{
    if (pred(*it))
        it = m.erase(it);
    else
        ++it;
} // UB before Cpp14

std::unordered_map<...> mymap;
std::vector<decltype(mymap)::key_type> vec;
for (auto&& i : mymap)
    if (/*compare i*/)
        vec.emplace_back(i.first);
for (auto&& key : vec)
    mymap.erase(key);
```

## Nested using 
```c++
template <typename T>
template <typename U>
using P = std::is_same<T, U>; // Usable in gcc, failed in clang
                              // ill-formed

```

## vector.resize()
* [discuss](https://www.zhihu.com/question/65997834/answer/237364710)

## tie and tie
```c++
int a = 1, b = 2, c = 3;
std::tie(a, b, c) = {c, a, b};
cout << a << ' ' << b; // 3 3 well-defined?
```